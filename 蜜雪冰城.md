![需求分析](./images/需求分析.png)

## 初始化项目

#### 创建项目

1. 使用测试号登录选用 TypeScript + Sass 版本的模板，进入项目

2. 先创建底部导航部分

*app.json*

```js
   {
     "pages": [
       "pages/index/index",
       "pages/menu/index",
       "pages/order/index",
       "pages/me/index"
     ],
     "window": {
       "backgroundTextStyle": "light",
       "navigationBarBackgroundColor": "#fff",
       "navigationBarTitleText": "Weixin",
       "navigationBarTextStyle": "black"
     },
     "tabBar": {
       "list": [
         {
           "pagePath": "pages/index/index",
           "text": "首页"
         },
         {
           "pagePath": "pages/menu/index",
           "text": "点餐"
         },
         {
           "pagePath": "pages/order/index",
           "text": "订单"
         },
         {
           "pagePath": "pages/me/index",
           "text": "我的"
         }
       ]
     },
     "style": "v2",
     "sitemapLocation": "sitemap.json"
   }
```

#### 首页轮播图和轮播图页面的跳转

1. project.config.json 中的 TypeScript 删除和 app.js 中的语法错误删除

```js
// project.config.json

"setting": {
    "useCompilerPlugins": [
      // "typescript",
      "sass"
    ],
        
// app.js 
App<IAppOption>({   -->   APP({})
```

2. pages/index/index.json

```js
{
  "navigationStyle": "custom"
} 
// 取消头部导航栏部分，这样就可以撑满整个屏幕
```

3.  pages/index/index.wxml

```html
   <view class="page">
    <view class="swiper-container">
     <swiper>
      <!-- 轮播里面包括图片，里面一个是轮播一个是轮播标识，里面一个是图片一个是跳转链接 mode="aspectFill" 防止图片变形-->
       <swiper-item wx:for="{{ swiperList }}" wx:key="index">
         <image mode="aspectFill" src="{{ item.imageUrl }}"></image>
       </swiper-item>
     </swiper>
     <view class="dots">
     <!-- 如果 current == index  会有一个 active 属性-->
         
     <view class="dot {{current !== index || 'active'}}" wx:for="{{ swiperList }}" wx:key="index"></view>
     </view>
    </view>
</view>
```

4. pages/index/index.scss

```js
.swiper-container{
  width: 100vw;
  height: 630rpx;
  swiper{
    height: 100%;
    image{
      width: 100%;
      height: 100%;
    }
  }
}
```

## 开始项目

#### 实现轮播图页面按钮样式切换

5. pages/index/index.wxml

```html
<view class="page">
 <view class="swiper-container">
 <!--3. 我们怎么知道图片切换去切换小圆圈的状态呢，这里有个bindchange事件 -->
  <swiper bindchange="onSwiperChange">
   <!--1. 轮播里面包括图片，里面一个是轮播一个是轮播标识，里面一个是图片一个是跳转链接 -->
    <swiper-item wx:for="{{ swiperList }}" wx:key="index">
      <image mode="aspectFill" src="{{ item.imageUrl }}"></image>
    </swiper-item>
  </swiper>
  <view class="dots">
  <!--2. 如果 current == index  会有一个 active 属性-->
  <view class="dot {{current !== index || 'active'}}" wx:for="{{ swiperList }}" wx:key="index"></view>
  </view>
 </view>
</view>
```

6. pages/index/index.scss

```scss
.swiper-container{
  width: 100vw;
  height: 630rpx;
  position: relative;
  swiper{
    height: 100%;
    image{
      width: 100%;
      height: 100%;
      // 下面有一点的弧度
      border-bottom-left-radius: 20rpx;
      border-bottom-right-radius: 20rpx;
    }
  }
  // 固定的区域，轮播图里面的切换图片的小标识
  .dots{
    position: absolute;
    left: 50rpx;
    bottom: 50rpx;
    // 这样的话下面的 dot 小圆圈就可以按照flex进行排布
    display: inline-flex;
    .dot{
      width: 8rpx;
      height: 8rpx;
      background-color: #fff;
      opacity: .5;
      // 因为上面是正方块，所以这里应该是半径 4rpx 的圆
      border-radius: 4rpx;
      // 每个小圆的间隔是 4rpx
      margin-left: 4rpx;
      // 1s 过渡
      transition: all 1s;
      &.active {
        // 如果是被选中状态的话，那么这里就会从圆变成一个条状的切换样式
        width: 29rpx;
        opacity: 1;
      }
    }
  }
}
```

7. pages/index/index.js

```js
// pages/index/index.ts
Page({

  /**
   * 页面的初始数据
   */
  data: {
    swiperList:[
      {
        imageUrl:'../../assets/images/lb1.png',
        type:'url',
        target:"http://baidu.com"
      },
      {
        imageUrl:'../../assets/images/lb2.png',
        // 跳转到产品具体的详情页
        type:'product',
        target:"1"
      },
      {
        imageUrl:'../../assets/images/lb3.png',
        type:'url',
        target:"http://baidu.com"
      }
    ],
    current:0
  },
  // 当轮播图切换的时候，调用这个方法，给 current 重新赋值，改变切换按钮的样式
  onSwiperChange(e){
    // 可以先进行解构，将里面的 current 拿出来
    const { current } = e.detail
    this.setData({
      current
    })
  }
})
```

#### 使用云开发的方式存储数据

1. 云开发-内容管理-访问地址-创建新项目蜜雪冰城-内容模型-新建模型

   ```js
   // 1.内容类型 图片
   1. 展示名称：轮播图
   2. 数据库字段名：imgUri
   3. 资源链接格式：HTTPS
   4. 是否必须：开启
   // 2.内容类型 枚举
   1. 展示名称：跳转类型
   2. 数据库字段名：type
   3. 资源链接格式：url
   4. 枚举元素类型：字符串
   5. 枚举元素：
     5.1 网址 url
     5.2 产品 product
   6. 是否必须：开启
   // 3. 内容类型 单行字符串
   1. 展示名称：目标
   2. 数据库字段名：target
   3. 是否必须：开启
   ```

2. 内容集合-轮播图-新建

   ```js
   1. 传入图片 
   跳转类型：网址 
   目标：https://baodu.com
   2. 传入图片 
   跳转类型：产品
   目标：123
   3. 传入图片
   跳转类型：产品
   目标：2
   ```

3. 获取云开发数据库中的数据

   api/swiper.js

   ```js
   // 这里是获取 swiper 的方式，简答的封装了一层API，获取数据可以通过这种方式获取
   // 但是这样定义之前需要先在 app.js 里面初始化
   import {db} from './cloud-init'
   const list = () => {
     return db.collection('mx_swiper').get();
   }
   
   export default {
     list
   }
   ```

   app.js

   ```js
   // app.ts
   App({
     globalData: {},
     onLaunch() {
       // 初始 cloud 功能，初始一下环境，才能调用方法 const db = wx.cloud.database() 去调用数据库
       wx.cloud.init();
   
       // 展示本地存储能力
       const logs = wx.getStorageSync('logs') || []
       logs.unshift(Date.now())
       wx.setStorageSync('logs', logs)
    
       // 登录
       wx.login({
         success: res => {
           console.log(res.code)
           // 发送 res.code 到后台换取 openId, sessionKey, unionId
         },
       })
     },
   })
   ```

   pages/index/index.js

   ```js
   import swiper from "../../api/swiper"
   
   // pages/index/index.ts
   Page({
     data: {
       // 创建一个空的数组元素   
       swiperList:[],
       current:0
     },
     // 当轮播图切换的时候，调用这个方法，给 current 重新赋值，改变切换按钮的样式
     onSwiperChange(e){
       // 可以先进行解构，将里面的 current 拿出来
       const { current } = e.detail
       this.setData({
         current
       })
     },
     /**
      * 生命周期函数--监听页面加载
      */
     onLoad() {
     // 在这里获取图片，我们通过在 api 里面封装了API，获取云开发中的数据
      swiper.list().then(res=>{
       // console.log(res);
        this.setData({
          swiperList:res.data
        })
      })
     }
   })
   ```

   pages/index/index.wxml

   ```html
   <view class="page">
   <!-- 如果 swiperList 里面没有数据不会渲染轮播图-->
    <view wx:if="{{swiperList.length}}" class="swiper-container">
    <!--3. 我们怎么知道图片切换去切换小圆圈的状态呢，这里有个bindchange事件 -->
     <swiper bindchange="onSwiperChange">
      <!--1. 轮播里面包括图片，里面一个是轮播一个是轮播标识，里面一个是图片一个是跳转链接 -->
       <swiper-item wx:for="{{ swiperList }}" wx:key="index">
         <image mode="aspectFill" src="{{ item.imgUri }}"></image>
       </swiper-item>
     </swiper>
     <view class="dots">
     <!--2. 如果 current == index  会有一个 active 属性-->
     <view class="dot {{current !== index || 'active'}}" wx:for="{{ swiperList }}" wx:key="index"></view>
     </view>
    </view>
   </view>
   ```

#### 实现轮播图的跳转功能

1. pages/index/index.wxml

   ```html
   <view class="page">
    <view wx:if="{{swiperList.length}}" class="swiper-container">
     <swiper bindchange="onSwiperChange">
       <swiper-item wx:for="{{ swiperList }}" wx:key="index">
        <!--绑定一个点击事件，并且把数据item传入，因为后续要对item里面的数据类型进行判断是如何进行跳转的-->   
         <image bindtap="onSwiperTab" data-item="{{item}}" mode="aspectFill" src="{{ item.imgUri }}"></image>
       </swiper-item>
     </swiper>
     <view class="dots">
     <view class="dot {{current !== index || 'active'}}" wx:for="{{ swiperList }}" wx:key="index"></view>
     </view>
    </view>
   </view>
   ```

2. pages/index/index.js

   ```js
   import swiper from "../../api/swiper"
   
   // pages/index/index.ts
   Page({
     data: {
       swiperList:[],
       current:0
     },
     //1. 当轮播图切换的时候，调用这个方法，给 current 重新赋值，改变切换按钮的样式
     onSwiperChange(e){
       // 可以先进行解构，将里面的 current 拿出来
       const { current } = e.detail
       this.setData({
         current
       })
     },
       
     // 轮播图的跳转效果，这里首先对其进行判断
     // 2. 当手指点图片的时候跳转页面
     onSwiperTab(e){
       // 获取传过来的数据，item
       const {item} = e.currentTarget.dataset
       // console.log(item);
       // 如果里面类型是type，说明是跳转的url，走第一个选项，如果不是走第二个
       item.type === 'url' ? wx.navigateTo({
         url: `/pages/web-view/index?url=${item.target}`,
       }) : wx.navigateTo({
         url: `/pages/product/detail?id=${item.target}`,
       })
     },
   
     onLoad() {
     // 在这里获取图片，我们通过在 api 里面封装了API，获取云开发中的数据
      swiper.list().then(res=>{
       // console.log(res);
        this.setData({
          swiperList:res.data
        })
      })
     }
   })
   ```

3. 创建两张页面 app.json

   ```js
   {
     "pages": [
       "pages/index/index",
       "pages/menu/index",
       "pages/order/index",
       "pages/me/index",
         
       // 创建出来两个需要跳转的页面
       "pages/web-view/index",
       "pages/product/detail"
     ],
     "window": {
       "backgroundTextStyle": "light",
       "navigationBarBackgroundColor": "#fff",
       "navigationBarTitleText": "Weixin",
       "navigationBarTextStyle": "black"
     },
     "tabBar": {
       "list": [
         {
           "pagePath": "pages/index/index",
           "text": "首页"
         },
         {
           "pagePath": "pages/menu/index",
           "text": "点餐"
         },
         {
           "pagePath": "pages/order/index",
           "text": "订单"
         },
         {
           "pagePath": "pages/me/index",
           "text": "我的"
         }
       ]
     },
     "style": "v2",
     "sitemapLocation": "sitemap.json"
   }
   ```

4. 获取需要跳转到的 url      pages/web-view/index.js

   ```js
    // pages/web-view/index.js
    Page({
      data: {
        url:null
      },

      onLoad(options) {
        // console.log(options.url); // 这里地址就过来了,地址赋值给上面data里面的url
        this.setData({
          url:options.url
        })
      }
    })
   ```

5. 设置跳转到的页面里面   pages/web-view/index.wxml

   ```js
	<view wx:if="{{url}}" src="{{url}}"></view>
   ```

#### Tabbar & 首页会员卡片

```js
1. 会员
   - 积分
	 - 我的积分
   - 会员成长值(分数)
2. 定位点餐
3. 今天喝什么
   - 公众号文章跳转
4. 优惠券
5. 积分商城(雪王魔法阵)
```

1. 底部 Tabbar

```js
{
  "pages": [
    "pages/index/index",
    "pages/menu/index",
    "pages/order/index",
    "pages/me/index",
    "pages/web-view/index",
    "pages/product/detail"
  ],
  "window": {
    "backgroundTextStyle": "light",
    "navigationBarBackgroundColor": "#fff",
    "navigationBarTitleText": "Weixin",
    "navigationBarTextStyle": "black"
  },
  "tabBar": {
    "color": "#797979",
    "selectedColor": "#E60012",
    "list": [
      {
        "pagePath": "pages/index/index",
        "text": "首页",
        "iconPath": "./assets/images/home.png",
        "selectedIconPath": "./assets/images/home-selected.png"
      },
      {
        "pagePath": "pages/menu/index",
        "text": "点餐",
        "iconPath": "./assets/images/menu.png",
        "selectedIconPath": "./assets/images/menu-selected.png"
      },
      {
        "pagePath": "pages/order/index",
        "text": "订单",
        "iconPath": "./assets/images/order.png",
        "selectedIconPath": "./assets/images/order-selected.png"
      },
      {
        "pagePath": "pages/me/index",
        "text": "我的",
        "iconPath": "./assets/images/me.png",
        "selectedIconPath": "./assets/images/me-selected.png"
      }
    ]
  },
  "style": "v2",
  "sitemapLocation": "sitemap.json"
}
```

2. app.scss

```scss
/**app.wxss**/
.page {
  background-color: #fefefe;
  display: flex;
  flex-direction: column;
  align-items: center;
} 
```

##### 会员卡片

1. pages/index/index.wxml

```html
<view class="page">
<!-- 1. 轮播图-->
 <view wx:if="{{swiperList.length}}" class="swiper-container">
 <!--3. 我们怎么知道图片切换去切换小圆圈的状态呢，这里有个bindchange事件 -->
  <swiper bindchange="onSwiperChange" autoplay="true" interval="3000" duration="1000" circular="true">
   <!--1. 轮播里面包括图片，里面一个是轮播一个是轮播标识，里面一个是图片一个是跳转链接 -->
    <swiper-item wx:for="{{ swiperList }}" wx:key="index">
      <image bindtap="onSwiperTab" data-item="{{item}}" mode="aspectFill" src="{{ item.imgUri }}"></image>
    </swiper-item>
  </swiper>
  <view class="dots">
  <!--2. 如果 current == index  会有一个 active 属性-->
  <view class="dot {{current !== index || 'active'}}" wx:for="{{ swiperList }}" wx:key="index"></view>
  </view>
 </view>
    
 <!--2. 会员/积分区域 -->
 <view class="member-area">
 <!-- 左侧会员区域 -->
 <view class="vip-box">
 <image src="../../assets/images/vip-pic.png"></image>
 <view class="meta">
 <view class="title">微雪花会员</view>
  <!-- 拆分组件部分 -->
 <progress-bar value="{{ 33 }}" width="320rpx"/>
 <view class="tips">再升1级可享【升级礼包】等6项权益</view>
 </view>

 <!-- 右侧积分区域 -->
 <view class="coin-box">
 <image src="../../assets/images/coin.png"></image>
 <view class="currency">51</view>
 </view>
 </view> 
 </view>
</view>
```

2. pages/index/index.json

```js
{
  "navigationStyle": "custom",
  "usingComponents": {
     // 引入组件
    "progress-bar":"../../components/progress-bar/index"
  }
} 
```

3. 创建组件经验条部分  components/progress-bar/index.wxml

```html
<!-- 经验条组件类型1
<view class="track" style="{{!trackColor ? 'background-color:' + trackColor + ';' : ''}} {{ width ? 'width:' + width + ';' : ''}}">
  <view class="bar" style="{{ value > 0 ? 'width:' + value + '%;' : ''}} {{!color|| 'background-color:' + color + ';'}}">
  </view>
</view> -->

<!-- 经验条组件类型二 -->
<!-- 如果正常情况下，这里判断就很麻烦，所以这里指定了两个属性，在js文件中，设置具体内容 -->
<view class="track" style="{{ trackStyle }}">
  <view class="bar" style="{{ barStyle }}">
  </view>
</view>
```

4. components/progress-bar/index.json

```js
{
  "component": true,
  "navigationStyle": "custom",
  "usingComponents": {
  }
}
```

5. components/progress-bar/index.js

```js
// components/progress-bar/index.js
Component({
  properties: {
    // 接收参数 color 是条的颜色
    color:{
      type:String,
      value:''
    },
    // trackColor 是背景的颜色
    trackColor:{
      type:String,
      value:''
    },
    // value就是一个值，这里一般都是百分比
    value:{
      type:Number,
      value:0
    },
    // 如果不加width，那么是占满整个区域，如果指定了width那么就可以限制区域
    width:{
      type:String,
      value:''
    }
  },
  data: {
  trackStyle:'',
  barStyle:'',
  },
lifetimes:{
  attached(){
    // 两个style的产出，这里是 组件被放在页面的时候 就去执行函数
    this.buildTrackStyle();
    this.buildBarStyle();
  }
},

  methods: {
    // buildTrackStyle对轨道进行计算，就是背景
    buildTrackStyle(){
      // 定义初始值，如果下面两个条件都没达到，那么就给值里面塞进去一个空的 trackStyle
      let trackStyle = '';
      // 判断width是否存在，如果存在加入 width 属性
      // 语法糖：如果前面是真的，就是传入了 width 那么就不会执行后面的部分，如果前面是false，才会执行后面的代码

      // if(this.properties.width){
      //   trackStyle += `width:${this.properties.width
      // } 
      // 与下面类似
      !this.properties.width || (trackStyle += `width:${this.properties.width};`)

      !this.properties.trackStyle || (trackStyle += `background-color:${this.properties.trackStyle};`)
      this.setData({
        trackStyle
      })
    },
    buildBarStyle(){
        // 定义初始值
        let barStyle = '';
        // 判断width是否存在，如果存在加入 width 属性，这里不是随便加的，如果是在0~100之间才加入进去，否则就不加入，并且后面是个数字，所以要加入%
        (this.properties.value <= 0 && this.properties.value >100) || (barStyle += `width:${this.properties.value}%;`)

        !this.properties.color || (barStyle += `background-color:${this.properties.color};`)
        this.setData({
          barStyle
        })
    }
  }
})
```

6. components/progress-bar/index.scss

```js
/* components/progress-bar/index.wxss */
.track{
  // 进度条部分
  background-color: #ebebeb;
  height: 6rpx;
  width: 100%;
  border-radius: 3rpx;
  // 进度条里面是竖装的，这里需要超出隐藏掉
  overflow: hidden;
}
.bar{
  background-color: #E60012;
  height: 100%;
  width: 0;
}
```

7. pages/index/index.scss

```scss
.swiper-container{
  width: 100vw;
  height: 630rpx;
  position: relative;
  swiper{
    height: 100%;
    image{
      width: 100%;
      height: 100%;
      // 下面有一点的弧度
      border-bottom-left-radius: 20rpx;
      border-bottom-right-radius: 20rpx;
    }
  }
  // 固定的区域，轮播图里面的切换图片的小标识
  .dots{
    position: absolute;
    left: 50rpx;
    bottom: 58rpx;
    // 这样的话下面的 dot 小圆圈就可以按照flex进行排布
    display: inline-flex;
    .dot{
      width: 8rpx;
      height: 8rpx;
      background-color: #fff;
      opacity: .5;
      // 因为上面是正方块，所以这里应该是半径 4rpx 的圆
      border-radius: 4rpx;
      // 每个小圆的间隔是 4rpx
      margin-left: 4rpx;
      // 1s 过渡
      transition: all 1s;
      &.active {
        // 如果是被选中状态的话，那么这里就会从圆变成一个条状的切换样式
        width: 29rpx;
        opacity: 1;
      }
    }
  }
}
.member-area{
  margin-top: -40rpx;
  z-index: 2;
  overflow: hidden;
  width: 688rpx;
  height: 174rpx;
  border-radius: 16rpx;
  background-color: #fefefe;
  // 给盒子一个阴影
  box-shadow: 0px 0px 8px rgba(0,0,0,0.2);
  display: flex;
  // 将盒子里面元素在同一行排布
  flex-direction: row;
  // 排布在盒子的两端
  justify-content: space-between;
  // 使图标显示在中间位置
  padding: 30rpx;
  // 这样防止盒子因为 padding 变大
  box-sizing: border-box;
  .vip-box{
    display: flex;
    image{
      width: 100rpx;
      height: 100rpx;
      border-radius: 50rpx;
      overflow: hidden;
      margin-right: 26rpx;
      // 这样不会在空间不够的情况下使图片变形，默认情况下是1，空间不够自动缩小
      flex-shrink: 0;
    }
    .meta{
      .title{
        font-size: 32rpx;
        font-weight: bold;
        margin-bottom: 18rpx;
      }
      .tips{
        margin-top: 14rpx;
        color: #777777;
        font-size: 24rpx;
      }
    }
  }
  .coin-box{
    display: flex;
    flex-direction: column;
    justify-content: center;
    margin-right: -45rpx;
    image{
      width: 130rpx;
      height: 70rpx;
    }
    .currency{
      color: #d32d25;
      margin-left: 26rpx;
      font-weight: bold;
    }
  }
}
```

#### 手机号码快捷登录

```js
思路：
云调用的方式，云开发会给我们提供一个云调用的机制，我们可以载运函数里面直接拿到加密的data传到云函数，云函数就可以拿到手机号，拿到手机号以后，我们就只要把手机号码存储到我们的后台用户列表里面，用户列表就会根据这边的数据，这个用户列表也只是手机号码，不会拿到其他的东西，比较简化一点，这个手机号码拿到以后，我们就可以在数据库的权限里面只能看到自己的手机号码的权限，这样就可以绑定这个手机号码，可以知道某一个手机号码是不是属于他的，再根据这个对数据进行筛选。我们对数据筛选我们可以用ID，我们在数据库写的时候，有些数据只是他自己能看到的，我们就用数据权限的方式去分割，不需要有太多的对用户的关联操作。
登录比较简单一点就是：暂时这里不需要gwt，给一个token这样非常复杂的登录体系
只需要保持当前的session，我们可以在data里面存储一个手机号码，如果没有登录，我们还不知道他是谁，这里必须要授权登录，然后去数据库里面查找，再提供区分的服务，简单的鉴权，以手机号码为主，当前如果localStorage里面存储了手机号码，我们只需要对这个手机号码提供服务就可以了，如果当前不是这个手机号码，我们就可以让选择手机号码登录，再对手机号码进行存储
```

1. app.json 创建一个登录页面

```js
{
  "pages": [
    "pages/index/index",
    "pages/menu/index",
    "pages/order/index",
    "pages/me/index",
    "pages/web-view/index",
    "pages/product/detail",
    "pages/login/index"
  ],
  "window": {
    "backgroundTextStyle": "light",
    "navigationBarBackgroundColor": "#fff",
    "navigationBarTitleText": "蜜雪冰城",
    "navigationBarTextStyle": "black"
  },
  "tabBar": {
    "color": "#797979",
    "selectedColor": "#E60012",
    "list": [
      {
        "pagePath": "pages/index/index",
        "text": "首页",
        "iconPath": "./assets/images/home.png",
        "selectedIconPath": "./assets/images/home-selected.png"
      },
      {
        "pagePath": "pages/menu/index",
        "text": "点餐",
        "iconPath": "./assets/images/menu.png",
        "selectedIconPath": "./assets/images/menu-selected.png"
      },
      {
        "pagePath": "pages/order/index",
        "text": "订单",
        "iconPath": "./assets/images/order.png",
        "selectedIconPath": "./assets/images/order-selected.png"
      },
      {
        "pagePath": "pages/me/index",
        "text": "我的",
        "iconPath": "./assets/images/me.png",
        "selectedIconPath": "./assets/images/me-selected.png"
      }
    ]
  },
  "style": "v2",
  "sitemapLocation": "sitemap.json"
}
```

2. pages/index/index.wxml

```html
<view class="page">
  <image class="logo" src="../../assets/images/me-avatar.png"></image>
  <view class="logo-title">蜜雪冰城</view>
  <view class="intro">成为会员，立享更多优惠福利</view>
  <view class="login-tip">授权绑定手机号 为您提供更好的服务</view>
  <button open-type="getPhoneNumber" class="login-btn"  bindgetphonenumber="login">一键登录</button>
  <view class="cancel" bindtap="">取消</view>
</view>
```

3. pages/index.index.scss

```scss
@import '../../style/theme.scss';
.page{
  padding-top: 176rpx;
  .logo{
    width: 150rpx;
    height: 150rpx;
    border-radius: 75rpx;
    overflow: hidden;
    margin-bottom: 22rpx;
  }
  .logo-title{
    margin-bottom: 160rpx;
  }
  .intro{
    font-size: 37rpx;
    font-weight: bold;
    margin-bottom: 84rpx;
  }
  .login-tip{
    font-size: 20rpx;
    color: $gray-text-color;
  }
  .login-btn{
    width: 368rpx;
    height: 85rpx;
    background-color:$primary-color;
    color: white;
    border-radius: 10rpx;
    display: flex;
    justify-content: center;
    align-items: center;
    margin-bottom: 42rpx;
    &.button-hover{
      opacity: 0.6;
    }
  }
  .cancel{
    color: #aaaaaa;
  }
}
```

4. style/theme.scss

```js
// 配置两个通用的颜色，需要的地方直接引入
$primary-color:#E60012;
$gray-text-color:#777777
```

5. 获取手机号暂时先不做，由于个人认证的用户无法获取手机号权限

```js
1. 先去创建 cloud-functions 文件夹
2. 然后去 project.config.json 中添加配置 "cloudfunctionRoot": "cloud-functions/",
    {
  "description": "项目配置文件",
  "packOptions": {
    "ignore": [],
    "include": []
  },
  "cloudfunctionRoot": "cloud-functions/",
  "miniprogramRoot": "miniprogram/",
  "compileType": "miniprogram",
  "projectname": "ts-sass-demo",
   "setting": {
       ...
   }
}
```

6. pages/login/index.js

```js
// pages/login/index.js
Page({

  /**
   * 页面的初始数据
   */
  data: {

  },
  login(e){
    // 注意这里如果是个人认证是没有办法拿到手机号的
    // console.log(e);
    const cloudId = e.detail.CloudID
    wx.cloud.callFunction({
      name:'get-phone-number',
      data:{
        weRunData: wx.clouod.CloudID(cloudId), // 这个 CloudID 值到云函数端会被替换
      }
    }).then(res=>{
      console.log(res);
    })
  },
  onLoad(options) {

  },
})
```

7. 选择做 如果想要看一下获取的都是那些信息，我们需要对云函数进行修改 

cloud-functions/get-phone-number/index.js

```js
// 云函数入口文件
const cloud = require('wx-server-sdk')

cloud.init()

// 云函数入口函数
exports.main = async (event, context) => {
   // return event.weRunData.data.phoneNumber
   // 改为
   return event.weRunData.data
}
// 然后这时候需要右键 cloud-functions/get-phone-number 文件夹-选择上传并部署所有文件
```

8. pages/index/index.js

```js
// pages/login/index.js
Page({

  /**
   * 页面的初始数据
   */
  data: {
    // 初始化登录成功后的跳转
    goto:''
  },
  login(e){
    // // 注意这里如果是个人认证是没有办法拿到手机号的
    // // console.log(e);
    // const cloudId = e.detail.CloudID
    // wx.cloud.callFunction({
    //   name:'get-phone-number',
    //   data:{
    //     weRunData: wx.clouod.CloudID(cloudId), // 这个 CloudID 值到云函数端会被替换
    //   }
    // }).then(res=>{
    //   // console.log(res);
    //   // 根据手机号码判断是否登录
    //   wx.setStorage("phoneNumber",res.result)
    //   // 跳转回来
    //   wx.switchTab({
    //     url: this.data.goto,
    //   })
    // })


    // 由于上面是个人用户，无法获取手机号，所以这里选择不去获取手机号，直接跳转页面
    wx.switchTab({
      url: this.data.goto,
    })
    wx.showToast({
      title: '登录成功',
      icon:"success",
      mask:true
    })
    wx.setStorageSync('phoneNumber', 132981691233)
  },
  onLoad(options) {
    const goto = '/pages/index/index'
    this.setData({
      goto
    })
  },

})
```

9. 然后对首页的登录状态进行修改 pages/index/index.js

```js
import swiper from "../../api/swiper"

// pages/index/index.ts
Page({

  /**
   * 页面的初始数据
   */
  data: {
    swiperList:[
      // {
      //   imageUri:'../../assets/images/lb1.png',
      //   type:'url',
      //   target:"http://baidu.com"
      // },
      // {
      //   imageUri:'../../assets/images/lb2.png',
      //   // 跳转到产品具体的详情页
      //   type:'product',
      //   target:"1"
      // },
      // {
      //   imageUri:'../../assets/images/lb3.png',
      //   type:'url',
      //   target:"http://baidu.com"
      // }
    ],
    current:0,    // 轮播图小图标切换
    memberInfo:null
  },

  //1. 当轮播图切换的时候，调用这个方法，给 current 重新赋值，改变切换按钮的样式
  onSwiperChange(e){
    // 可以先进行解构，将里面的 current 拿出来
    const { current } = e.detail
    this.setData({
      current
    })
  },
  // 2. 当手指点图片的时候跳转页面
  onSwiperTab(e){
    // 获取传过来的数据，item
    const {item} = e.currentTarget.dataset
    // console.log(item);
    // 如果里面类型是type，说明是跳转的url，走第一个选项，如果不是走第二个
    item.type === 'url' ? wx.navigateTo({
      url: `/pages/web-view/index?url=${item.target}`,
    }) : wx.navigateTo({
      url: `/pages/product/detail?id=${item.target}`,
    })
  },
  // 登录按钮操作
  gotoLogin(){
    wx.navigateTo({
      url: '/pages/login/index',
    })
  },
  /**
   * 生命周期函数--监听页面加载
   */
  onLoad() {
  // 在这里获取图片，我们通过在 api 里面封装了API，获取云开发中的数据
   swiper.list().then(res=>{
    // console.log(res);
     this.setData({
       swiperList:res.data
     })
   })
  },
  onShow(){
    // 去拿手机号数据，如果有数据，那么就说明登录过了
    this.loadNumberInfo()
  },
  loadNumberInfo(){
   if(wx.getStorageSync('phoneNumber')){
    this.setData({
      memberInfo:wx.getStorageSync('phoneNumber')
    })
   }
  }
})
```

10. pages/login/index.wxml

```html
<view class="page">
<!-- 1. 轮播图-->
 <view wx:if="{{swiperList.length}}" class="swiper-container">
 <!--3. 我们怎么知道图片切换去切换小圆圈的状态呢，这里有个bindchange事件 -->
  <swiper bindchange="onSwiperChange" autoplay="true" interval="3000" duration="1000" circular="true">
   <!--1. 轮播里面包括图片，里面一个是轮播一个是轮播标识，里面一个是图片一个是跳转链接 -->
    <swiper-item wx:for="{{ swiperList }}" wx:key="index">
      <image bindtap="onSwiperTab" data-item="{{item}}" mode="aspectFill" src="{{ item.imgUri }}"></image>
    </swiper-item>
  </swiper>
  <view class="dots">
  <!--2. 如果 current == index  会有一个 active 属性-->
  <view class="dot {{current !== index || 'active'}}" wx:for="{{ swiperList }}" wx:key="index"></view>
  </view>
 </view>
 <!--2. 会员/积分区域 -->
 <view class="member-area">
 <!-- 左侧会员区域 -->
 <view class="vip-box">
 <image src="../../assets/images/vip-pic.png"></image>
 <view class="meta">
 <view class="title">{{memberInfo ? '微雪花会员' : '尊敬的用户'}}</view>
 <progress-bar value="{{ 33 }}" width="320rpx"/>
 <view class="tips">{{memberInfo ? '再升1级可享【升级礼包】等6项权益' :'会员可享【闲时优惠】等多项权益'}}</view>
 </view>
</view> 

 <!-- 右侧积分区域 -->
 <!-- 登录状态 -->
 <view wx:if="{{ memberInfo }}"  class="coin-box">
 <image src="../../assets/images/coin.png"></image>
 <view class="currency">51</view>
 </view>
<!-- 非登录状态，显示按钮 -->
<view wx:if="{{ !memberInfo }}" class="login-btn" bindtap="gotoLogin">授权登录</view>
 </view>
</view>
```

#### 首页&我的页面

1. pages/index/index.wxml

```html
<view class="page">
  <!-- 1. 轮播图-->
  <view wx:if="{{swiperList.length}}" class="swiper-container">
    <!--3. 我们怎么知道图片切换去切换小圆圈的状态呢，这里有个bindchange事件 -->
    <swiper bindchange="onSwiperChange" autoplay="true" interval="3000" duration="1000" circular="true">
      <!--1. 轮播里面包括图片，里面一个是轮播一个是轮播标识，里面一个是图片一个是跳转链接 -->
      <swiper-item wx:for="{{ swiperList }}" wx:key="index">
        <image bindtap="onSwiperTab" data-item="{{item}}" src="{{ item.imgUri }}"></image>
      </swiper-item>
    </swiper>
    <view class="dots">
      <!--2. 如果 current == index  会有一个 active 属性-->
      <view class="dot {{current !== index || 'active'}}" wx:for="{{ swiperList }}" wx:key="index"></view>
    </view>
  </view>
  <!--2. 会员/积分区域 -->
  <view class="member-area">
    <!-- 左侧会员区域 -->
    <view class="vip-box">
      <image src="../../assets/images/vip-pic.png"></image>
      <view class="meta">
        <view class="title">{{memberInfo ? '微雪花会员' : '尊敬的用户'}}</view>
        <progress-bar value="{{ 33 }}" width="320rpx" />
        <view class="tips">{{memberInfo ? '再升1级可享【升级礼包】等6项权益' :'会员可享【闲时优惠】等多项权益'}}</view>
      </view>
    </view>

    <!-- 右侧积分区域 -->
    <!-- 登录状态 -->
    <view wx:if="{{ memberInfo }}" class="coin-box">
      <image src="../../assets/images/coin.png"></image>
      <view class="currency">51</view>
    </view>
    <!-- 非登录状态，显示按钮 -->
    <view wx:if="{{ !memberInfo }}" class="login-btn" bindtap="gotoLogin">授权登录</view>
  </view>

  <!-- 点餐banner star-->
  <view class="menu-banner">
    <view class="location">
      <image src="../../assets/images/address.png"></image>
      <view class="name">万达店</view>
    </view>
    <image class="menu-card" src="../../assets/images/menu-banner.jpg" bindtap="onMenuCardClick"></image>
  </view>
  <!-- 点餐banner end -->
</view>

<view class="banner-list">
  <image class="banner" src="../../assets/images/banner-1.jpg" bindtap="onArticleClick"></image>
  <image class="banner" src="../../assets/images/banner-2.jpg"></image>
  <image class="banner" src="../../assets/images/banner-3.jpg"></image>
</view>
```

2. pages/index/index.scss

```js
// 这里引入通用的颜色
@import '../../style/theme.scss';
.swiper-container{
  width: 100vw;
  height: 630rpx;
  position: relative;
  swiper{
    height: 100%;
    image{
      width: 100%;
      height: 100%;
      // 下面有一点的弧度
      border-bottom-left-radius: 20rpx;
      border-bottom-right-radius: 20rpx;
    }
  }
  // 固定的区域，轮播图里面的切换图片的小标识
  .dots{
    position: absolute;
    left: 50rpx;
    bottom: 58rpx;
    // 这样的话下面的 dot 小圆圈就可以按照flex进行排布
    display: inline-flex;
    .dot{
      width: 8rpx;
      height: 8rpx;
      background-color: #fff;
      opacity: .5;
      // 因为上面是正方块，所以这里应该是半径 4rpx 的圆
      border-radius: 4rpx;
      // 每个小圆的间隔是 4rpx
      margin-left: 4rpx;
      // 1s 过渡
      transition: all 1s;
      &.active {
        // 如果是被选中状态的话，那么这里就会从圆变成一个条状的切换样式
        width: 29rpx;
        opacity: 1;
      }
    }
  }
}
.member-area{
  margin-top: -40rpx;
  z-index: 2;
  overflow: hidden;
  width: 688rpx;
  height: 174rpx;
  border-radius: 16rpx;
  background-color: #fefefe;
  // 给盒子一个阴影
  box-shadow: 0px 0px 8px rgba(0,0,0,0.2);
  display: flex;
  // 将盒子里面元素在同一行排布
  flex-direction: row;
  // 排布在盒子的两端
  justify-content: space-between;
  align-items: center;
  // 使图标显示在中间位置
  padding: 0 20rpx;
  // 这样防止盒子因为 padding 变大
  box-sizing: border-box;
  margin-bottom: 44rpx;
  .vip-box{
    display: flex;
    image{
      width: 100rpx;
      height: 100rpx;
      border-radius: 50rpx;
      overflow: hidden;
      margin-right: 26rpx;
      // 这样不会在空间不够的情况下使图片变形，默认情况下是1，空间不够自动缩小
      flex-shrink: 0;
    }
    .meta{
      .title{
        font-size: 32rpx;
        font-weight: bold;
        margin-bottom: 18rpx;
      }
      .tips{
        margin-top: 14rpx;
        // 这里修改一下颜色的值
        // color:#777777
        color: $gray-text-color;
        font-size: 24rpx;
      }
    }
  }
  .coin-box{
    display: flex;
    flex-direction: column;
    justify-content: center;
    margin-right: -23rpx;
    image{
      width: 130rpx;
      height: 70rpx;
    }
    .currency{
      color: #d32d25;
      margin-left: 26rpx;
      font-weight: bold;
    }
  }
  //登录按钮样式
  .login-btn{
    width: 150rpx;
    height: 65rpx;
    border-radius: 10rpx;
    background-color: $primary-color;
    color: #fff;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 25rpx;
    &active{
      opacity: 0.6;
    }
  }
}

// 点餐区域
.menu-banner{
  width: 100%;
  padding: 0 28rpx;
  box-sizing: border-box;
  .location{
  display: flex;
  align-items: center;
  margin-bottom: 15rpx;
    image{
      margin-left: 10rpx;
      width: 24rpx;
      height: 24rpx;
    }
    .name{
      font-size: 22rpx;
      color: black;
      margin-left: 14rpx;
    }
  }
  .menu-card{
    width: 688rpx;
    height: 340rpx;
    box-shadow: 0px 0px 8px rgba(0,0,0,0.1);
    border-radius: 16rpx;
  }
}
.banner-list{
  display: flex;
  width: 100%;
  box-sizing: border-box;
  padding: 0 30rpx;
  justify-content: space-between;
  margin-bottom: 36rpx;
  .banner{
    width: 216rpx;
    height: 160rpx;
    box-shadow: 0px 0px 8px rgba(0,0,0,0.1);
    border-radius: 16rpx;
  }
}
```

3. pages/index/index.js

```js
import swiper from "../../api/swiper"

// pages/index/index.ts
Page({

  /**
   * 页面的初始数据
   */
  data: {
    swiperList:[
      // {
      //   imageUri:'../../assets/images/lb1.png',
      //   type:'url',
      //   target:"http://baidu.com"
      // },
      // {
      //   imageUri:'../../assets/images/lb2.png',
      //   // 跳转到产品具体的详情页
      //   type:'product',
      //   target:"1"
      // },
      // {
      //   imageUri:'../../assets/images/lb3.png',
      //   type:'url',
      //   target:"http://baidu.com"
      // }
    ],
    current:0,    // 轮播图小图标切换
    memberInfo:null
  },

  //1. 当轮播图切换的时候，调用这个方法，给 current 重新赋值，改变切换按钮的样式
  onSwiperChange(e){
    // 可以先进行解构，将里面的 current 拿出来
    const { current } = e.detail
    // console.log(current);
    this.setData({
      current
    })
  },
  // 2. 当手指点图片的时候跳转页面
  onSwiperTab(e){
    // 获取传过来的数据，item
    const {item} = e.currentTarget.dataset
    // console.log(item);
    // 如果里面类型是type，说明是跳转的url，走第一个选项，如果不是走第二个
    item.type === 'url' ? wx.navigateTo({
      url: `/pages/web-view/index?url=${item.target}`,
    }) : wx.navigateTo({
      url: `/pages/product/detail?id=${item.target}`,
    })
  },
  // 登录按钮操作
  gotoLogin(){
    wx.navigateTo({
      url: '/pages/login/index',
    })
  },

  // 点击点餐卡片跳转至菜单页
  onMenuCardClick(){
   if(wx.getStorageSync('phoneNumber')){
    wx.switchTab({
      url: '/pages/menu/index',
    })
   }else{
    wx.showToast({
      title: '请先登录',
      image:'../../assets/images/home-selected.png',
      mask:true,   //是否显示透明蒙层，防止触摸穿透，默认：false
    })
   }
  },
  // 点击最下面的去文章页面
  onArticleClick(){
    wx.navigateTo({
      url: '/pages/web-view/index?url=http://www.zhangqilong.cn',
    })
  },

  /**
   * 生命周期函数--监听页面加载
   */
  onLoad() {
  // 在这里获取图片，我们通过在 api 里面封装了API，获取云开发中的数据
   swiper.list().then(res=>{
    // console.log(res);
     this.setData({
       swiperList:res.data
     })
   })
  },
  onShow(){
    // 去拿手机号数据
    this.loadNumberInfo()
  },
  loadNumberInfo(){
   if(wx.getStorageSync('phoneNumber')){
    this.setData({
      memberInfo:wx.getStorageSync('phoneNumber')
    })
   }
  }
})
```

4. pages/index/index.json

```json
{
  "navigationStyle": "custom",
  "usingComponents": {
    "progress-bar":"../../components/progress-bar/index"
  }
} 
```

#### 我的页面

1. pages/me/index.wxml

```html
<!--pages/me/index.wxml-->
<view class="page">
  <!-- 用户区域 -->
  <view class="user-area">
    <view class="user-box">
      <image class="avatar" src="{{imgUri}}"></image>
      <view class="name">{{ phoneNumber || '登录获得更多会员权益' }}</view>
    </view>
    <view wx:if="{{ !phoneNumber }}" class="login-btn" bindtap="login">授权登录</view>
  </view>
  <!-- 卡片区域 -->
  <view  class="card-container">
    <!-- one -->
    <view class="card">
      <view class="meta">
        <view class="count">54</view>
        <view class="name">雪王币</view>
      </view>
      <image class="icon" src="../../assets/images/me-coin.png"></image>
    </view>
    <!-- second -->
    <view class="card">
      <view class="meta">
        <view class="count">54</view>
        <view class="name">优惠券</view>
      </view>
      <image class="icon" src="../../assets/images/me-coupon.png"></image>
    </view>
  </view>
  <!-- list区域 -->
  <view class="list-items">
    <view class="item">
      <view class="content">
        <image class="icon" src="../../assets/images/qr-code.png"></image>
        <view class="label">兑换码</view>
      </view>
      <image class="left-arrow" src="../../assets/images/right.png"></image>
    </view>
    <!-- second -->
    <view class="item">
      <view class="content">
        <image class="icon" src="../../assets/images/lock.png"></image>
        <view class="label">隐私政策</view>
      </view>
      <image class="left-arrow" src="../../assets/images/right.png"></image>
    </view>
    <!-- third -->
    <view class="item">
      <view class="content">
        <image class="icon" src="../../assets/images/paper.png"></image>
        <view class="label">用户协议</view>
      </view>
      <image class="left-arrow" src="../../assets/images/right.png"></image>
    </view>
    <!-- forth -->
    <view class="item">
      <view class="content">
        <image class="icon" src="../../assets/images/xuke.png"></image>
        <view class="label">经营信息公示</view>
      </view>
      <image class="left-arrow" src="../../assets/images/right.png"></image>
    </view>
  </view>
  <!-- fifth -->
  <view class="list-items app-download">
      <view class="item">
      <view class="content">
        <image class="icon" src="../../assets/images/app.png"></image>
        <view class="label">蜜雪冰城APP</view>
      </view>
      <view class="tips">下载APP体验更佳</view>
    </view>
    </view>
</view>
```

2. pages/me/index.scss

```scss
/* pages/me/index.wxss */
@import '../../style/theme.scss';
.page{
  // 渐变色，需要配合 height width 使用
  background: linear-gradient(to bottom,#fbe7e6,#f8f8f8);
  // view height 可视窗高度
  height: 100vh;
  width: 100%;
  box-sizing: border-box;
  padding: 0 30rpx;
  padding-top: 170rpx;
  .user-area{
    width: 100%;
    display: flex;
    align-items: center;
    justify-content: space-between;
    .user-box{
      display: flex;
      align-items: center;
      .avatar {
        width: 120rpx;
        height: 120rpx;
      }
      .name{
        font-size: 28rpx;
        margin-left: 24rpx;
      }
    }
    .login-btn{
      width: 150rpx;
      height: 62rpx;
      background-color: $primary-color;
      color: #fff;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 25rpx;
      font-weight: bold;
      &.active{
        opacity: 0.6;
      }
    }
  }
  // 卡片区域
  .card-container{
    width: 100%;
    display: flex;
    justify-content: space-between;
    margin-bottom: 26rpx;
    .card{
      width: 330rpx;
      box-sizing: border-box;
      padding: 23rpx;
      border-radius: 15rpx;
      display: flex;
      margin-top: 20rpx;
      background-color: #fff;
      justify-content: space-between;
      align-items: center;
      .meta{
        .count{
          font-size: 24rpx;
          font-weight: bold;
        }
        .name{
          margin-top: 5rpx;
          font-size: 24rpx;
          color: $gray-text-color;
        }
      }
      .icon{
        width: 72rpx;
        height: 72rpx;
      }
    }
  }
  // list区域
  .list-items{
    display: flex;
    width: 100%;
    flex-direction: column;
    margin-bottom: 26rpx;
    .item{
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 36rpx 30rpx;
      background-color: #fff;
      .content{
        display: flex;
        align-items: center;
        .icon{
          width: 40rpx;
          height: 40rpx;
          margin-right: 25rpx;
        }
        .label{
          font-size: 30rpx;
        }
      }
      .left-arrow{
        width: 30rpx;
        height: 30rpx;
      }
    }
    &.app-download{
    .tips{
      margin-right: 10rpx;
      font-size: 24rpx;
      color: $gray-text-color;
    } 
    }
  }
}
```

3. pages/me/index.js

```js
1. 在这里面，由于登录的操作是有两处，一个是在首页点餐的时候，我们需要登录。另外一个就是在我的页面的时候需要登录，但是由于我们之前设置的登录页面，登录之后返回的是首页。但是有个问题就是如果我们在我的页面的时候同样调用了login页面，那么我们在我的页面登录之后返回的也是首页，这样就非常的不合理，那么我是如何做的呢？，
2. 首先我在我的页面调用登录页的时候，我们可以传入一个参数 /pages/login/index?from=me
 login(){
    wx.navigateTo({
      url: '/pages/login/index?from=me',
    })
  },
3. 这样我们就可以在登录页的 onLoad(options)里面做一个判断，我们传入的参数是包括在onLoad(options)的options参数里面，这样我们就可以在没有手机号授权的情况下也可以进行判断是哪里来的，然后去精准控制要返回的页面

 onLoad(options) {
 // 从这个可以接收到调用login页面时候传入的参数，这样就可以精准控制要返回的页面，比如首页和我的页面都有登录操作，如果不能获取手机号的情况下，我们可以传入参数进行判断，是从哪里来的，比如这里就是传入了 from:me 进行得知
    console.log('login.js',options); 
       
    if(options.from == 'me'){
    // 如果是从我的页面来的
      const goto = '/pages/me/index'
      this.setData({
        goto
      })
    }else{
      // 如果是从首页登录来的
      const goto = '/pages/index/index'
      this.setData({
        goto
      })
    }
  },
      
4. 同理在点击取消的时候，我们也可以这样设置
// 取消登录
  cancel(){
    wx.switchTab({
      // url: '/pages/index/index',
      // 这里直接用的是判断之后的 goto 地址
      url:this.data.goto
    })
  },
```

```js
// pages/me/index.ts
Page({

  data: {
    phoneNumber:'',   // 手机号码
    imgUri:'../../assets/images/me-avatar.png',  // 图片地址
  },
  // 登录操作
  login(){
    wx.navigateTo({
      url: '/pages/login/index?from=me',
    })
  },
  onShow() {
    const phoneNumber = wx.getStorageSync('phoneNumber')
    this.setData({
      phoneNumber
    })
    if(phoneNumber){
      this.setData({
        imgUri:'../../assets/images/vip-pic.png'
      })
    }
  }
})
```

4. pages/login/index.js

```js
// pages/login/index.js
Page({

  /**
   * 页面的初始数据
   */
  data: {
    // 初始化登录成功后的跳转
    goto:''
  },
  login(e){
    // // 注意这里如果是个人认证是没有办法拿到手机号的
    // // console.log(e);
    // const cloudId = e.detail.CloudID
    // wx.cloud.callFunction({
    //   name:'get-phone-number',
    //   data:{
    //     weRunData: wx.clouod.CloudID(cloudId), // 这个 CloudID 值到云函数端会被替换
    //   }
    // }).then(res=>{
    //   // console.log(res);
    //   // 根据手机号码判断是否登录
    //   wx.setStorage("phoneNumber",res.result)
    //   // 跳转回来
    //   wx.switchTab({
    //     url: this.data.goto,
    //   })
    // })
    // 由于上面是个人用户，无法获取手机号，所以这里选择不去获取手机号，直接跳转页面
    wx.switchTab({
      url: this.data.goto,
    })
    wx.showToast({
      title: '登录成功',
      icon:"success",
      mask:true
    })
    wx.setStorageSync('phoneNumber', 132981691233)
  },
  // 取消登录
  cancel(){
    wx.switchTab({
      // url: '/pages/index/index',
      // 这里直接用的是判断之后的 goto 地址
      url:this.data.goto
    })
  },
  onLoad(options) {
// 从这个可以接收到调用login页面时候传入的参数，这样就可以精准控制要返回的页面，比如首页和我的页面都有登录操作，如果不能获取手机号的情况下，我们可以传入参数进行判断，是从哪里来的，比如这里就是传入了 from:me 进行得知
    console.log('login.js',options); 
       
    if(options.from == 'me'){
    // 如果是从我的页面来的
      const goto = '/pages/me/index'
      this.setData({
        goto
      })
    }else{
      // 如果是从首页登录来的
      const goto = '/pages/index/index'
      this.setData({
        goto
      })
    }
  },
})
```

5. 我们如果想要对账户信息处理，只让显示几位的话，那么我们就可以使用小程序中的 computed计算属性，来对数据进行处理，当然也可以使用 filter过滤(小程序中不推荐)，那么我们就需要先引入computed，官方文档-平台能力-扩展能力-框架扩展-computed- https://github.com/wechat-miniprogram/computed ，在使用之前，需要先把 package.json和package-lock.json 删除，然后就需要在miniprogram文件夹下使用 npm install --save miniprogram-computed，然后工具-构建npm，出来的 miniprogram_npm 就是我们需要的东西

```js
1. 在pages/me/index.js中引入 const computedBehavior = require('miniprogram-computed').behavior
2. 在Page({})里面引入
Page({
  //2. 引入
  behaviors: [computedBehavior],
    ...
 )}
3. 然后引入computed，与 data 同级别
computed: {
    sum(data) {
      // 注意： computed 函数中不能访问 this ，只有 data 对象可供访问
      // 这个函数的返回值会被设置到 this.data.sum 字段中
      return data.a + data.b + data.c // data.c 为自定义 behavior 数据段
    },
  },
```

6. pages/me/index.js

```js
// pages/me/index.ts
// 1. 引入
const computedBehavior = require('miniprogram-computed').behavior
Page({
  //2. 引入
  behaviors: [computedBehavior],
  data: {
    phoneNumber:'',   // 手机号码
    imgUri:'../../assets/images/me-avatar.png',  // 图片地址
  },
  //3. 引入
  computed: {
    // 脱敏
    desensitiveMobile(data) {
      // 注意： computed 函数中不能访问 this ，只有 data 对象可供访问
      // 这个函数的返回值会被设置到 this.data.sum 字段中
      let phoneNumber = data.phoneNumber.toString()
      if(phoneNumber){
      // {\d3} 是前三位的数字 {\d2}是后两位， {\d6}对中间内容进行处理
      phoneNumber = phoneNumber.replace(/^(\d{3})\d{6}(\d{2})$/,"$1******$2");
      }
      return phoneNumber
    },
  },
  // 登录操作
  login(){
    wx.navigateTo({
      url: '/pages/login/index?from=me',
    })
  },
  onShow() {
    const phoneNumber = wx.getStorageSync('phoneNumber')
    this.setData({
      phoneNumber
    })
    if(phoneNumber){
      this.setData({
        imgUri:'../../assets/images/vip-pic.png'
      })
    }
  }
})
```

7. pages/me/index.wxml 在页面中将 phoneNumber 替换成 desensitiveMobile

```html
<!--pages/me/index.wxml-->
<view class="page">
  <!-- 用户区域 -->
  <view class="user-area">
    <view class="user-box">
      <image class="avatar" src="{{imgUri}}"></image>
        
      <!-- desensitiveMobile 是在computed中对电话脱敏后的数据 -->
      <view class="name">{{ desensitiveMobile || '登录获得更多会员权益' }}</view>
    </view>
    <view wx:if="{{ !phoneNumber }}" class="login-btn" bindtap="login">授权登录</view>
  </view>
  <!-- 卡片区域 -->
  <view  class="card-container">
    <!-- one -->
    <view class="card">
      <view class="meta">
        <view class="count">54</view>
        <view class="name">雪王币</view>
      </view>
      <image class="icon" src="../../assets/images/me-coin.png"></image>
    </view>
    <!-- second -->
    <view class="card">
      <view class="meta">
        <view class="count">54</view>
        <view class="name">优惠券</view>
      </view>
      <image class="icon" src="../../assets/images/me-coupon.png"></image>
    </view>
  </view>
  <!-- list区域 -->
  <view class="list-items">
    <view class="item">
      <view class="content">
        <image class="icon" src="../../assets/images/qr-code.png"></image>
        <view class="label">兑换码</view>
      </view>
      <image class="left-arrow" src="../../assets/images/right.png"></image>
    </view>
    <!-- second -->
    <view class="item">
      <view class="content">
        <image class="icon" src="../../assets/images/lock.png"></image>
        <view class="label">隐私政策</view>
      </view>
      <image class="left-arrow" src="../../assets/images/right.png"></image>
    </view>
    <!-- third -->
    <view class="item">
      <view class="content">
        <image class="icon" src="../../assets/images/paper.png"></image>
        <view class="label">用户协议</view>
      </view>
      <image class="left-arrow" src="../../assets/images/right.png"></image>
    </view>
    <!-- forth -->
    <view class="item">
      <view class="content">
        <image class="icon" src="../../assets/images/xuke.png"></image>
        <view class="label">经营信息公示</view>
      </view>
      <image class="left-arrow" src="../../assets/images/right.png"></image>
    </view>
  </view>
  <!-- fifth -->
  <view class="list-items app-download">
      <view class="item">
      <view class="content">
        <image class="icon" src="../../assets/images/app.png"></image>
        <view class="label">蜜雪冰城APP</view>
      </view>
      <view class="tips">下载APP体验更佳</view>
    </view>
    </view>
</view>
```

#### 标签切换组件&搜索框

1. pages/store/index.wxml

```html
<view class="page">
  <view class="header">
  <!-- 可以设置数组和对象，对象有利于指定key  抽离切换栏组件-->
   <tabs tabs="{{ [{value:'nearby',label:'附近门店'},{value:'recent',label:'常去门店'}] }}"></tabs>
      <!-- 输入框 -->
      <input type="text" class="search" placeholder="搜索门店"/>
  </view>
  <!-- map 区域 -->
  <view class="map">
  </view>
  <!--  -->
  <view class="collapse-area">
  </view>
</view>
```

2. pages/store/index.scss

```scss
.header{
  display: flex;
  padding:0 30rpx;
  box-sizing: border-box;
  width: 100%;
  justify-content: space-between;
  align-items: center;
  height: 109rpx;
  .search{
    width: 174rpx;
    height: 58rpx;
    background-color: #f5f5f5;
    padding: 18rpx 26rpx;
    border-radius: 29rpx;
    box-sizing: border-box;
    padding:0 26rpx;
    font-size: 28rpx;
    color: #d1d1d1;
  }
}
```

3. pages/store/index.json  抽离组件

```json
{
  "usingComponents": {
    "tabs":"../../components/tabs"
  },
  "navigationBarTitleText": "门店列表"
}
```

4. components/tabs/index.wxml

```html
<!--components/tabs/index.wxml-->

<view class="tabs">
    <!-- 文字内容 -->
      <view class="tab {{index === current ? 'active':''}}" bindtap="onTab" data-index="{{index}}" wx:for="{{tabs}}" wx:key="index">{{item.label}}</view>
    <!-- 底部线的样式 -->
      <view class="line" style="{{ 'width: ' + linePositionWidth + 'px; left: ' + linePositionX + 'px'}}"></view>
</view>  
```

5. components/tabs/index.scss

```scss
/* components/tabs/index.wxss 
$primary-color:#E60012;
$gray-text-color:#777777
*/
@import '../../style/theme.scss';
.tabs{
  display: flex;
  position: relative;
  .tab{
    font-size: 28rpx;
    margin-right: 20rpx;
    color: #777777;
    &.active{
      color: #000000;
      font-weight: bold;
    }
  }
  .line{
    background-color:$primary-color;
    width: 70rpx;
    height: 4rpx;
    position: absolute;
    bottom: -22rpx;
    left: 0;
    transition: all .3s;
  }
}
```

6. components/tabs/index.json

```json
{
  "component": true,
  "usingComponents": {
    
  }
}
```

7. components/tabs/index.js   重点内容，借用了API-WXML-[SelectorQuery.exec](https://developers.weixin.qq.com/miniprogram/dev/api/wxml/SelectorQuery.html)

```js
// components/tabs/index.js
Component({
  properties: {
    tabs:{
      type:Array,
      value:[]
    }
  },
  data: {
    current:0,   // 控制切换门店的样式
    linePositionX:0,  // 线的定位信息
    linePositionWidth:0, // 线的长度
  },
  // 组件生命周期
  lifetimes:{
    // 在组件实例进入页面节点树时执行
    attached(){
      // 页面刚加载的时候，需要调用一次
      this.calculateLinePositionX()
    }
  },
  methods: {
    onTab(e){
      // console.log(e.currentTarget.dataset);
      const {index} = e.currentTarget.dataset
      this.setData({
        current:index
      })
    //1. 将每次切换后的index，传入进去，因为里面有两个 class=".tab" 的元素，那么我们就需要传入一个index来确定是哪一个
    this.calculateLinePositionX(index)
    },
    // 经过计算，下面的线可以设置到中间区域
    calculateLinePositionX(index = 0){
      this.createSelectorQuery().selectAll('.tab').boundingClientRect(results=>{
        // 2. 获取具体的元素的位置信息
        const rect = results[index]
        //3. 文字的中心点坐标
        const currentCenterX = rect.left +  rect.width/2
        //4. 线的长度
        const linePositionWidth = rect.width * 0.8
        //5. 线的左侧坐标 但是这样需要注意的是，我们需要拿掉第一个元素的 padding-left
        const linePositionX = currentCenterX - linePositionWidth/2 - results[0].left
        this.setData({
          linePositionWidth,
          linePositionX
        })
      }).exec() 
    }
  }
})
```

##### 地图信息

1. pages/store/index.wxml

```html
<view class="page">
    
  <view class="header">
    <!-- 可以设置数组和对象，对象有利于指定key  抽离切换栏组件-->
    <tabs tabs="{{ [{value:'nearby',label:'附近门店'},{value:'recent',label:'常去门店'}] }}"></tabs>
    <input type="text" class="search" placeholder="搜索门店" />
  </view>
    
  <!-- map 区域  从官方直接拿 longitude latitude经纬度 bindmarkertap点开时候的位置 -->
  <map id="store-map" class="store-map" latitude="{{latitude}}" longitude="{{longitude}}" show-location markers="{{markers}}">
    <image bindtap="gotoCurrentLocation" class="current-icon" src="../../assets/images/current.png"></image>
  </map>
    
  <!-- 收起地图文字信息  -->
  <view class="collapse-area">
    <view class="collapse-tip">收起地图</view>
    <image src="../../assets/images/up.png"></image>
  </view>
</view>
```

2. pages/store/index.scss

```scss
@import '../../style/theme.scss';
.header{
  display: flex;
  padding:0 30rpx;
  box-sizing: border-box;
  width: 100%;
  justify-content: space-between;
  align-items: center;
  height: 109rpx;
  .search{
    width: 174rpx;
    height: 58rpx;
    background-color: #f5f5f5;
    padding: 18rpx 26rpx;
    border-radius: 29rpx;
    box-sizing: border-box;
    padding:0 26rpx;
    font-size: 28rpx;
    color: #d1d1d1;
  }
}
.store-map{
  width: 100%;
  height: 520rpx;
  position: relative;
  .current-icon{
    width: 44rpx;
    height: 44rpx;
    position: absolute;
    right: 18rpx;
    bottom: 22rpx;
  }
}
.collapse-area{
  width: 100%;
  height: 70rpx;
  display: flex;
  justify-content: center;
  align-items: center;
  font-size: 23rpx;
  color: $gray-text-color;
  image{
    width: 30rpx;
    height: 30rpx;
    margin-left: 10rpx;
  }
}
```

3. pages/store/index.js

```js
// pages/store/index.js
Page({
  data: {
    longitude:113.613347,
    latitude:34.748349,
    // 地图上的蜜雪冰城标记点，自定义 markers
    markers:[
      {id:1,title:'实际位置',latitude:34.748349,longitude:113.613347,iconPath:'../../assets/images/marker.png', 
      width:'55rpx',height:'69rpx'}
    ]
  },
  //1. 在当前页面增加了一个成员变量 mapContext
  mapContext:null,

  onLoad(options) {
    // 获取当前位置信息
    wx.getLocation({
      type: 'gcj02',
      altitude: true, //高精度定位
      success: (res)=> {
        console.log(111);
        const latitude = res.latitude
        const longitude = res.longitude
        this.setData({
          latitude,
          longitude
        })
      }
     })
    // 点击右下角小图标返回当前位置  
    wx.createSelectorQuery().select('#store-map').context(res=>{
      //2. 刚加载页面的时候我们进行一个对 mapContext 的获取
      this.mapContext = res.context;
    }).exec()
  },
  //3. 点击回到中心点位置
  gotoCurrentLocation(){
    // 4. 任何一个位置只要点击就回到当前位置
    this.mapContext.moveToLocation()
  }
})
```

4. pages/store/index.json

```json
{
  "usingComponents": {
    "tabs":"../../components/tabs"
  },
  "navigationBarTitleText": "门店列表"
}
```

##### 点餐商铺列表

1. pages/store/index.wxml

```html
<view class="page">
  <view class="header">
    <!-- 可以设置数组和对象，对象有利于指定key  抽离切换栏组件-->
    <tabs tabs="{{ [{value:'nearby',label:'附近门店'},{value:'recent',label:'常去门店'}] }}"></tabs>
    <input type="text" class="search" placeholder="搜索门店" />
  </view>
  <!-- map 区域  从官方直接拿 longitude latitude经纬度 bindmarkertap点开时候的位置 -->
  <map id="store-map" class="store-map" latitude="{{latitude}}" longitude="{{longitude}}" show-location markers="{{markers}}">
    <image bindtap="gotoCurrentLocation" class="current-icon" src="../../assets/images/current.png"></image>
  </map>
  <!-- 收起地图文字信息  -->
  <view class="collapse-area">
    <view class="collapse-tip">收起地图</view>
    <image src="../../assets/images/up.png"></image>
  </view>
  <!-- 店铺信息 -->
  <scroll-view class="store-list" scroll-y>
    <view class="store-box" wx:for="2" wx:key="*this">
      <view class="info-area">
        <view class="name">蜜雪冰城（潘水店）</view>
        <view class="info">郑州市191号</view>
        <view class="info">营业时间: 09:00 ~ 22:00 </view>
        <view class="tag">营业中</view>
      </view>
      <view class="location-area">
        <view class="distance">距离1.3km</view>
        <view class="action-area">
          <view class="location">
        <image class="location" src="../../assets/images/location.jpg"></image>
            <image class="phone" src="../../assets/images/phone.jpg"></image>
          </view>
        </view>
      </view>
    </view>
  </scroll-view>
</view>
```

2. pages/store/index.scss

```scss
@import '../../style/theme.scss';
.header{
  display: flex;
  padding:0 30rpx;
  box-sizing: border-box;
  width: 100%;
  justify-content: space-between;
  align-items: center;
  height: 109rpx;
  .search{
    width: 174rpx;
    height: 58rpx;
    background-color: #f5f5f5;
    padding: 18rpx 26rpx;
    border-radius: 29rpx;
    box-sizing: border-box;
    padding:0 26rpx;
    font-size: 28rpx;
    color: #d1d1d1;
  }
}
.store-map{
  width: 100%;
  height: 520rpx;
  position: relative;
  .current-icon{
    width: 44rpx;
    height: 44rpx;
    position: absolute;
    right: 18rpx;
    bottom: 22rpx;
  }
}
.collapse-area{
  width: 100%;
  height: 70rpx;
  display: flex;
  justify-content: center;
  align-items: center;
  font-size: 23rpx;
  color: $gray-text-color;
  image{
    width: 30rpx;
    height: 30rpx;
    margin-left: 10rpx;
  }
}
.store-list{
  width: 100%;
  height: calc(100vh - 700rpx);
  background-color: #f8f8f8;
  // 小程序一般都是怪异盒子模型，所以一般都是需要设置 box-sizing 的
  box-sizing: border-box;
  .store-box{
    background-color: #ffffff;
    padding:25rpx;
    margin: 14rpx 25rpx;
    display: flex;
    align-items: center;
    .info-area{
      border-right: 1px solid #eeeeee;
      // 这样弹性盒子的效果就出来了，占满后面的空间
      flex: 1;
      .name{
        font-size: 28rpx;
        font-weight: bold;
        margin-bottom:12rpx;
      }
      .info{
        font-size: 18rpx;
        color: $gray-text-color;
        margin-bottom: 12rpx;
      }
      .tag{
        // 这样不是一个block，是一个inline的话就可以做 padding 了
        display: inline-block;
        background-color: $primary-color;
        color: #fff;
        font-size: 18rpx;
        padding: 6rpx;
      }
    }
    .location-area{
      height: 112rpx;
      margin-left: 25rpx;
      display: flex;
      flex-direction: column;
      align-items: center;
      .distance{
        font-size: 20rpx;
        color: $gray-text-color;
        margin-bottom: 35rpx;
      }
      .action-area{
        display: flex;
        width: 112rpx;
        justify-content: space-around;
        image{
          width: 40rpx;
          height: 40rpx;
        }
      }
    }
  }
}
```

3. pages/store/index.js  

```js
// pages/store/index.js
Page({
  data: {
    longitude:113.613347,
    latitude:34.748349,
    // 地图上的蜜雪冰城标记点，自定义 markers
    markers:[
      {id:1,title:'实际位置',latitude:34.748349,longitude:113.613347,iconPath:'../../assets/images/marker.png', 
      width:'55rpx',height:'69rpx'}
    ]
  },
  //1. 在当前页面增加了一个成员变量 mapContext
  mapContext:null,

  onLoad(options) {
    // 获取当前位置信息
    wx.getLocation({
      type: 'gcj02',
      altitude: true, //高精度定位
      success: (res)=> {
        console.log(111);
        const latitude = res.latitude
        const longitude = res.longitude
        this.setData({
          latitude,
          longitude
        })
      }
     })
    // 点击右下角小图标返回当前位置  
    wx.createSelectorQuery().select('#store-map').context(res=>{
      //2. 刚加载页面的时候我们进行一个对 mapContext 的获取
      this.mapContext = res.context;
    }).exec()
  },
  //3. 点击回到中心点位置
  gotoCurrentLocation(){
    // 4. 任何一个位置只要点击就回到当前位置
    this.mapContext.moveToLocation()
  }
})
```

4. pages/store/index.json

```json
{
  "usingComponents": {
    "tabs":"../../components/tabs"
  },
  "navigationBarTitleText": "门店列表"
}
```

#### 门店模型&前后端联调

```js
1. 准备工作，云开发-内容管理-内容模型-新建模型-展示名称：门店名称-数据库名：store-创建事件(系统字段名)：created_time-更新时间(系统)字段名:updated_time-创建
2. 单行字符串-展示名称：门店名称 - 数据库字段名：name - 是否必须：true
3. 数字-展示名称：经度 - 数据库字段名：latitude - 是否必须：true
4. 数字-展示名称：维度 - 数据库字段名：longitude - 是否必须：true
5. 枚举-展示名称：开店状态 - 数据库字段名：status - 默认值：CLOSED - 枚举元素类型：字符串 - 枚举元素：已关店 CLOSED，营业中 OPENING - 是否必须：true
6. 单行字符串-展示名称：营业时间 - 数据库字段名：opening_time - 默认值：09:00 ~ 22:00 - 是否必须：true
7. 单行字符串-展示名称：门店地址 - 数据库字段名：address - 是否必须：true
8. 电话号码-展示名称：联系电话 - 数据库字段名：phone 
// 字段名创建好之后，创建内容
1. 内容集合-门店-新建
// 经纬度可以去小程序官方文档-组件-地图map-小程序地图插件使用指南-开发文档-工具-坐标拾取器中查找
2. 蜜雪冰城(朗悦公园茂潮流茂店)-34.818552-113.554637-营业中-河南省郑州市中原区迎春街52号朗悦公园茂潮流茂F3 - 13203719565
3. 蜜雪冰城(中原路桐柏路店)-34.747757-113.612985-营业中-河南省郑州市中原区建设路街道中原路桐柏路交汇处西北角42号楼1楼东 - 17335569598
4.蜜雪冰城(五一公园店)-34.755933-113.615897-营业中-河南省郑州市中原区建设路桐柏路交叉口向东50米建设路路北公交站牌 - 18637185285
5. 蜜雪冰城(工人路店)-34.743013-113.620637-营业中-河南省郑州市中原区工人路100号
6. 蜜雪冰城(CC mall西元国际广场购物中心店)-34.757442-113.601681-营业中-河南省郑州市中原区建设路与秦岭路交汇处CC_mall西元国际广场购物中心B1 - 13213122210
7. 蜜雪冰城(锦艺轻纺城店)-34.766001-113.52428-营业中-河南省郑州市中原区须水河东路以东西四环以西锦艺国际轻纺城配套住宅底商9#-14号 - 13103719137
```

1. api/store.js  获取数据的API

```js
const db = wx.cloud.database()

const list = () => {
  // 只拿10个数据，这里必须要get()才会调用
  return db.collection('store').limit(10).get()
}


export default {
  list
}
```

2. pages/store/index.js   对方法进行了重构，看起来更简洁

```js
// pages/store/index.js
import storeApi from '../../api/store'
Page({
  data: {
    longitude:113.613347,
    latitude:34.748349,
    // 地图上的蜜雪冰城标记点，自定义 markers
    markers:[
      {id:1,title:'实际位置',latitude:34.748349,longitude:113.613347,iconPath:'../../assets/images/marker.png', 
      width:'55rpx',height:'69rpx'}
    ],
    storeList:[],    // 门店列表数据  
    // 但是我们里面的 status 是OPENING，我们需要对应成 营业中
    dict:{
      'OPENING':'营业中',
      'CLOSED':'已关店'
    }
  },
  //1. 在当前页面增加了一个成员变量 mapContext
  mapContext:null,

  onLoad(options) {
    // 调用封装的获取位置信息方法
    this.loadCurrentLocation()  
    // 作用从当前位置获取context，并且赋值到成员变量mapContext中
    this.initMapContext()
    // 获取storeList的方法
    this.fetchStoreList()
  },
  
  // 封装获取位置信息方法
  loadCurrentLocation(){
    // 获取当前位置信息
    wx.getLocation({
      type: 'gcj02',
      altitude: true, //高精度定位
      success: (res)=> {
        console.log(111);
        const latitude = res.latitude
        const longitude = res.longitude
        this.setData({
          latitude,
          longitude
        })
      }
    })
  },

  // 封装加载 mapContext的方法
  initMapContext(){
    // 点击右下角小图标返回当前位置  
    wx.createSelectorQuery().select('#store-map').context(res=>{
      //2. 刚加载页面的时候我们进行一个对 mapContext 的获取
      this.mapContext = res.context;
    }).exec()
  },

  // 获取门店列表数据方法
  fetchStoreList(){
    storeApi.list().then(res =>{
      // 只是这样获取data是空的，创建的模型在数据库中默认是谁创建谁来看，因为在上下文中会拿到openId，然后当前模拟用户里面是没有openId的，所以这里没有权限拿到这些东西。进入云开发-数据库-store-数据权限-所有用户可读，仅创建者可读写
      // console.log(res);
      this.setData({
        storeList:res.data
      })
    })
  },

  //3. 点击回到中心点位置
  gotoCurrentLocation(){
    // 4. 任何一个位置只要点击就回到当前位置
    this.mapContext.moveToLocation()
  }
})
```

3. pages/store/index.wxml   对数据进行渲染

```html
<view class="page">
  <view class="header">
    <!-- 可以设置数组和对象，对象有利于指定key  抽离切换栏组件-->
    <tabs tabs="{{ [{value:'nearby',label:'附近门店'},{value:'recent',label:'常去门店'}] }}"></tabs>
    <input type="text" class="search" placeholder="搜索门店" />
  </view>
  <!-- map 区域  从官方直接拿 longitude latitude经纬度 bindmarkertap点开时候的位置 -->
  <map id="store-map" class="store-map" latitude="{{latitude}}" longitude="{{longitude}}" show-location markers="{{markers}}">
    <image bindtap="gotoCurrentLocation" class="current-icon" src="../../assets/images/current.png"></image>
  </map>
  <!-- 收起地图文字信息  -->
  <view class="collapse-area">
    <view class="collapse-tip">收起地图</view>
    <image src="../../assets/images/up.png"></image>
  </view>
  <!-- 店铺信息 -->
  <scroll-view class="store-list" scroll-y>
    <view class="store-box" wx:for="{{storeList}}" wx:key="index">
      <view class="info-area">
        <view class="name">{{ item.name }}</view>
        <view class="info">{{item.address}}</view>
        <view class="info">营业时间: {{item.opening_time}}</view>
        <!-- <view class="tag">{{item.status}}</view> 这里需要对数据进行处理，小程序过滤器有点问题 -->
        <view class="tag">{{dict[item.status]}}</view>
      </view>
      <view class="location-area">
        <view class="distance">距离1.3km</view>
        <view class="action-area">
          <view class="location">
            <image class="location" src="../../assets/images/location.jpg"></image>
            <image class="phone" src="../../assets/images/phone.jpg"></image>
          </view>
        </view>
      </view>
    </view>
  </scroll-view>
</view>
```

4. pages/store/index.js    

```js
1. 处理距离数据的思路：
根据列表里面的经度和维度，再匹配当前位置的经度维度，把距离计算出来，增加一个新的属性，塞到storeList里面
2. 根据经纬度获取距离：我们可以进入 组件-map-小程序地图插件使用指南-开发文档-微信小程序JavaScript SDK-申请开发者密钥（key）：申请密钥
3. 开通webserviceAPI服务：控制台 ->应用管理 -> 我的应用 ->添加key-> 勾选WebServiceAPI -> 保存
4. 下载微信小程序JavaScriptSDK，微信小程序JavaScriptSDK v1.1   JavaScriptSDK v1.2(下载这个，放进utils里面，然后在 pages/store/index.js中引入)
var QQMapWX = require('../../utils/qqmap-wx-jssdk.min');
5. 安全域名设置，在小程序管理后台 -> 开发 -> 开发管理 -> 开发设置 -> “服务器域名” 中设置request合法域名，添加https://apis.map.qq.com(或者勾选不检测域名)
6. 在app.json中声明获取位置信息
"permission": {
    "scope.userLocation": {
      "desc": "你的位置信息将用于获取附近门店"
    }
  },
  "requiredPrivateInfos": [
    "getLocation"
  ],
  "tabBar": {
      ...
  }
```

```js
// pages/store/index.js
//1. 引入SDK核心类，js文件根据自己业务，位置可自行放置
var QQMapWX = require('../../utils/qqmap-wx-jssdk.min');
import storeApi from '../../api/store';
Page({
  data: {
    longitude:113.613347,
    latitude:34.748349,
    // 地图上的蜜雪冰城标记点，自定义 markers
    markers:[
      {id:1,title:'实际位置',latitude:34.748349,longitude:113.613347,iconPath:'../../assets/images/marker.png', 
      width:'55rpx',height:'69rpx'}
    ],
    storeList:[],    // 门店列表数据  
    // 但是我们里面的 status 是OPENING，我们需要对应成 营业中
    dict:{
      'OPENING':'营业中',
      'CLOSED':'已关店'
    }
  },
  // 在当前页面增加了一个成员变量 mapContext，封装到全局变量中全局就可以调用
  mapContext:null,
  // 2. 定义全局 mapSdk
  mapSdk:null,

  onLoad(options) {
    // 调用封装的获取位置信息方法
    this.loadCurrentLocation()  
    // 作用从当前位置获取context，并且赋值到成员变量mapContext中
    this.initMapContext()
    // 获取storeList的方法
    this.fetchStoreList()
    //3. sdk的方法
    this.initMapSdk();
  },
  
  // 封装获取位置信息方法
  loadCurrentLocation(){
    // 获取当前位置信息
    wx.getLocation({
      type: 'gcj02',
      altitude: true, //高精度定位
      success: (res)=> {
        console.log(111);
        const latitude = res.latitude
        const longitude = res.longitude
        this.setData({
          latitude,
          longitude
        })
      }
    })
  },

  // 封装加载 mapContext的方法
  initMapContext(){
    // 点击右下角小图标返回当前位置  
    wx.createSelectorQuery().select('#store-map').context(res=>{
      // 刚加载页面的时候我们进行一个对 mapContext 的获取
      this.mapContext = res.context;
    }).exec()
  },

  // 获取门店列表数据方法
  fetchStoreList(){
    storeApi.list().then(res =>{
      // 只是这样获取data是空的，创建的模型在数据库中默认是谁创建谁来看，因为在上下文中会拿到openId，然后当前模拟用户里面是没有openId的，所以这里没有权限拿到这些东西。进入云开发-数据库-store-数据权限-所有用户可读，仅创建者可读写
      // console.log(res);
      //5. 在数据放入storeList列表之前，先对数据进行排序处理
      const storeList = this.makeStoreList(res.data)
      this.setData({
        storeList:res.data
      })
    })
  },

  //6. 对数据进行处理的方法
  makeStoreList(data){
    // 对数据进行构造，使用let，对数据构造完，可以一直塞入数据
    let storeList = [];
    // 根据列表里面的经度和维度，再匹配当前位置的经度维度，把距离计算出来，增加一个新的属性，塞到storeList里面
    const locationList = data.map(item=>{
      return {
        latitude:item.latitude,
        longitude:item.longitude,
       }
    })
    // 调用微信小程序JavaScript SDK 里面距离计算的方法 调用距离计算接口
    this.mapSdk.calculateDistance({
        //from参数不填默认当前地址
        //获取表单提交的经纬度并设置from和to参数（示例为string格式）
        // from: 若起点有数据则采用起点坐标，若为空默认当前地址，可以不写
        to: locationList, //终点坐标
        success:(res)=>{//成功后的回调
          console.log(res);
        },
        fail: function(error) {
          console.error(error);
        }
    })
    return data
  },

  //4. SDK方法
  initMapSdk(){
  // 实例化SDK 
    this.mapSdk = new QQMapWX({
      // 文档-组件-map-小程序地图插件使用指南-开发文档-微信小程序JavaScript SDK - 申请密匙-开启不验证域名-没有报错-文档-距离计算
      key:'5CSBZ-GOXKJ-2STFF-FFMDX-25IGO-KSBQ6'
    })
  },

  // 点击回到中心点位置
  gotoCurrentLocation(){
    // 任何一个位置只要点击就回到当前位置
    this.mapContext.moveToLocation()
  }
})
```

5. 问题及解决思路

```js
1. 当我们打印出来res之后，我们就获取到了数据，但是云数据库中没有提供地址的存储字段，那么我们可以在云开发-数据库中增加一个字段的方式进行跑通(可以使用)，或者正常开发中，我们是需要在云开发CMS里面添加一个地理位置模型，挑选地理位置的的时候加载腾讯地图的选择器，在腾讯地图里面搜索某个地址关键词，找到这个位置，点一下这个位置，就把他的经纬度直接获取过去，但是云开发的CMS里面是没有地址位置的字段，所以我们这里则是对数据库就行增加一个字段的方式实现
2. 进入云开发-数据库-store-选中某一条-添加字段：类型geopoint，字段：location，经度，维度按照字段里面的数据填写即可
3. 开发者资源 /SDK 文档 /数据库 /Command /查询·地理位置操作符 /geoNear
const _ = db.command
db.collection('restaurants').where({
  location: _.geoNear({
    geometry: db.Geo.Point(113.323809, 23.097732),
    minDistance: 1000,
    maxDistance: 5000,
  })
}).get()
4. 云开发-数据库-添加索引-索引名称：geno - 唯一 - 索引字段：location 地址位置
文档中说明了要根据位置获取数据，需要添加索引字段
索引要求： 需对查询字段建立地理位置索引https://developers.weixin.qq.com/miniprogram/dev/wxcloud/reference-sdk-api/database/command/Command.geoNear.html
5. 对 store.js 进行改造
```

api.store.js

```js
const db = wx.cloud.database()
const _ = db.command
const list = (longitude,latitude) => {
  // 只拿10个数据，这里必须要get()才会调用
  // return db.collection('store').limit(10).get()
  // 改造获取最近距离的门店
  return db.collection('store').where({
    location:_.geoNear({
      geometry: db.Geo.Point(longitude,latitude),
      // 最小距离可选
      // minDistance: 1000,
      // 最大距离，5公里内数据都可以拿到，这里就可以修改数据去获取多远范围内的数据
      maxDistance: 10000,
    })
  }).limit(10).get()
}

export default {
  list
}
```

6. pages/store/index.js

```js
// pages/store/index.js
//1. 引入SDK核心类，js文件根据自己业务，文件位置可自行放置
var QQMapWX = require('../../utils/qqmap-wx-jssdk.min');
import storeApi from '../../api/store';
Page({
  data: {
    longitude:113.613347,
    latitude:34.748349,
    // 地图上的蜜雪冰城标记点，自定义 markers
    markers:[
      {id:1,title:'实际位置',latitude:34.748349,longitude:113.613347,iconPath:'../../assets/images/marker.png', 
      width:'55rpx',height:'69rpx'}
    ],
    storeList:[],    // 门店列表数据  
    // 但是我们里面的 status 是OPENING，我们需要对应成 营业中
    dict:{
      'OPENING':'营业中',
      'CLOSED':'已关店'
    }
  },
  // 在当前页面增加了一个成员变量 mapContext，封装到全局变量中全局就可以调用
  mapContext:null,
  // 2. 定义全局 mapSdk
  mapSdk:null,

 async onLoad(options) {
    // 调用封装的获取位置信息方法
    this.loadCurrentLocation()  
    // 作用从当前位置获取context，并且赋值到成员变量mapContext中
    this.initMapContext()
    // 获取storeList的方法，在拿到位置数据信息之后再执行，或者将这个方法放进loadCurrentLocation方法里面
    await this.fetchStoreList()
    //3. sdk的方法
    this.initMapSdk();
  },
  
  // 封装获取位置信息方法
  loadCurrentLocation(){
    // 获取当前位置信息
    wx.getLocation({
      type: 'gcj02',
      altitude: true, //高精度定位
      success: (res)=> {
        const latitude = res.latitude
        const longitude = res.longitude
        this.setData({
          latitude,
          longitude
        })
      }
    })
  },

  // 封装加载 mapContext的方法
  initMapContext(){
    // 点击右下角小图标返回当前位置  
    wx.createSelectorQuery().select('#store-map').context(res=>{
      //2. 刚加载页面的时候我们进行一个对 mapContext 的获取
      this.mapContext = res.context;
    }).exec()
  },

  // 获取门店列表数据方法
  fetchStoreList(){
    //7. 改造之后，这里需要传入参数，这里获取的门店数据是store.js里面修改后的多远范围内的数据
    storeApi.list(this.data.longitude,this.data.latitude).then(res =>{
      // 只是这样获取data是空的，创建的模型在数据库中默认是谁创建谁来看，因为在上下文中会拿到openId，然后当前模拟用户里面是没有openId的，所以这里没有权限拿到这些东西。进入云开发-数据库-store-数据权限-所有用户可读，仅创建者可读写
      // console.log(res);
      //5. 在数据放入storeList列表之前，先对数据进行排序处理
      this.makeStoreList(res.data)
    })
  },

  //6. 对数据进行处理的方法
  makeStoreList(storeList){
    // 根据列表里面的经度和维度，再匹配当前位置的经度维度，把距离计算出来，增加一个新的属性，塞到storeList里面
    const locationList = storeList.map(item=>{
      return {
        //8. 这里根据数据库中的字段获取经纬度，如果只有一个location字段可以选用第一种方式获取
        latitude:item.location.latitude,
        longitude:item.location.longitude,
        // latitude:item.latitude,
        // longitude:item.longitude,
       }
    })
    // 调用微信小程序JavaScript SDK 里面距离计算的方法 调用距离计算接口
    this.mapSdk.calculateDistance({
        //from参数不填默认当前地址
        //获取表单提交的经纬度并设置from和to参数（示例为string格式）
        // from: 若起点有数据则采用起点坐标，若为空默认当前地址，可以不写
        to: locationList, //终点坐标
        success:(res)=>{//成功后的回调
          //9. 获取到数据，对storeList进行处理
          // console.log(res);
          storeList.forEach((item,key)=>{
            //10. 给storeList添加一个新的键（distance）和值，并且将米转成千米
            storeList[key]['distance'] =( res.result.elements[key].distance/1000).toFixed(2)
          })
          this.setData({
            storeList
          })
        },
        fail: function(error) {
          console.error(error);
        }
    })
    // 10.上面塞进去之后这里就不需要return数据了
    // return data
  },

  //SDK方法
  initMapSdk(){
  // 实例化SDK 
    this.mapSdk = new QQMapWX({
      // 文档-组件-map-小程序地图插件使用指南-开发文档-微信小程序JavaScript SDK - 申请密匙-开启不验证域名-没有报错-文档-距离计算
      key:'5CSBZ-GOXKJ-2STFF-FFMDX-25IGO-KSBQ6'
    })
  },

  //点击回到中心点位置
  gotoCurrentLocation(){
    //任何一个位置只要点击就回到当前位置
    this.mapContext.moveToLocation()
  }
})
```

7. pages/store/index.html  对距离数据进行渲染

```html
<view class="page">
  <view class="header">
    <!-- 可以设置数组和对象，对象有利于指定key  抽离切换栏组件-->
    <tabs tabs="{{ [{value:'nearby',label:'附近门店'},{value:'recent',label:'常去门店'}] }}"></tabs>
    <input type="text" class="search" placeholder="搜索门店" />
  </view>
  <!-- map 区域  从官方直接拿 longitude latitude经纬度 bindmarkertap点开时候的位置 -->
  <map id="store-map" class="store-map" latitude="{{latitude}}" longitude="{{longitude}}" show-location markers="{{markers}}">
    <image bindtap="gotoCurrentLocation" class="current-icon" src="../../assets/images/current.png"></image>
  </map>
  <!-- 收起地图文字信息  -->
  <view class="collapse-area">
    <view class="collapse-tip">收起地图</view>
    <image src="../../assets/images/up.png"></image>
  </view>
  <!-- 店铺信息 -->
  <scroll-view class="store-list" scroll-y>
    <view class="store-box" wx:for="{{storeList}}" wx:key="index">
      <view class="info-area">
        <view class="name">{{ item.name }}</view>
        <view class="info">{{item.address}}</view>
        <view class="info">营业时间: {{item.opening_time}}</view>
    <!-- <view class="tag">{{item.status}}</view> 这里需要对数据进行处理，小程序过滤器有点问题 -->
        <view class="tag">{{dict[item.status]}}</view>
      </view>
      <view class="location-area">
        <view class="distance">距离 {{item.distance}} km</view>
        <view class="action-area">
          <view class="location">
            <image class="location" src="../../assets/images/location.jpg"></image>
            <image class="phone" src="../../assets/images/phone.jpg"></image>
          </view>
        </view>
      </view>
    </view>
  </scroll-view>
</view>
```

#### 实现对地图标识 markers

1. pages/store/index.js

```js
实现思路：对获取到过滤后的门店信息进行处理，获取他们的经纬度，并且借助 computed 属性进行对数据处理，返回一个新的 markers，对图标进行渲染，只要 storeList 发生变化，那么对应的 markers 就会发生变化，所以这样我们只需要操作 storeList 里面的数据即可
```

```js
// pages/store/index.js
// 11. 引入计算属性，对markers进行处理
const computedBehavior = require('miniprogram-computed').behavior
//1. 引入SDK核心类，js文件根据自己业务，位置可自行放置
var QQMapWX = require('../../utils/qqmap-wx-jssdk.min');
import storeApi from '../../api/store';
Page({
  //12. 引入
  behaviors: [computedBehavior],
  data: { 
    longitude:113.613347,
    latitude:34.748349,
    // 地图上的蜜雪冰城标记点，自定义 markers
    // 14. 这里将原来的 markers 删除
    // markers:[ 
    //   {id:1,title:'实际位置',latitude:34.748349,longitude:113.613347,iconPath:'../../assets/images/marker.png', 
    //   width:'55rpx',height:'69rpx'}
    // ],
    storeList:[],    // 门店列表数据  
    // 但是我们里面的 status 是OPENING，我们需要对应成 营业中
    dict:{
      'OPENING':'营业中',
      'CLOSED':'已关店'
    },
  },
   // 13. 对markers数据进行处理
   computed: {
    // 根据形参里面的值的变化，去动态的修改 markers 的变化
    markers(data) {
      console.log(data.storeList);
    // 注意： computed 函数中不能访问 this ，只有 data 对象可供访问
   return data.storeList.map(item=>{
      return {
        id:item._id,
        title:item.name,
        latitude:item.location.latitude,
        longitude:item.location.longitude,
        iconPath:'../../assets/images/marker.png',
        width:'55rpx', height:'69rpx'
      }
    })
  },
},

  //1. 在当前页面增加了一个成员变量 mapContext，封装到全局变量中全局就可以调用
  mapContext:null,
  // 2. 定义全局 mapSdk
  mapSdk:null,

 async onLoad(options) {
    // 调用封装的获取位置信息方法
    this.loadCurrentLocation()  
    // 作用从当前位置获取context，并且赋值到成员变量mapContext中
    this.initMapContext()
    // 获取storeList的方法，在拿到位置数据信息之后再执行，或者将这个方法放进loadCurrentLocation方法里面
    await this.fetchStoreList()
    //3. sdk的方法
    this.initMapSdk();
  },

  //3. 点击回到中心点位置
  gotoCurrentLocation(){
    // 4. 任何一个位置只要点击就回到当前位置
    this.mapContext.moveToLocation()
  },
  
  // 封装获取位置信息方法
  loadCurrentLocation(){
    // 获取当前位置信息
    wx.getLocation({
      type: 'gcj02',
      altitude: true, //高精度定位
      success: (res)=> {
        const latitude = res.latitude
        const longitude = res.longitude
        this.setData({
          latitude,
          longitude
        })
      }
    })
  },

  // 封装加载 mapContext的方法
  initMapContext(){
    // 点击右下角小图标返回当前位置  
    wx.createSelectorQuery().select('#store-map').context(res=>{
      //2. 刚加载页面的时候我们进行一个对 mapContext 的获取
      this.mapContext = res.context;
    }).exec()
  },

  // 获取门店列表数据方法
  fetchStoreList(){
    //7. 改造之后，这里需要传入参数，这里获取的门店数据是store.js里面修改后的多远范围内的数据
    storeApi.list(this.data.longitude,this.data.latitude).then(res =>{
      // 只是这样获取data是空的，创建的模型在数据库中默认是谁创建谁来看，因为在上下文中会拿到openId，然后当前模拟用户里面是没有openId的，所以这里没有权限拿到这些东西。进入云开发-数据库-store-数据权限-所有用户可读，仅创建者可读写
      // console.log(res);
      //5. 在数据放入storeList列表之前，先对数据进行排序处理
      this.makeStoreList(res.data)
    })
  },

  //6. 对数据进行处理的方法
  makeStoreList(storeList){
    // 根据列表里面的经度和维度，再匹配当前位置的经度维度，把距离计算出来，增加一个新的属性，塞到storeList里面
    const locationList = storeList.map(item=>{
      return {
        //8. 这里根据数据库中的字段获取经纬度，如果只有一个location字段可以选用第一种方式获取
        latitude:item.location.latitude,
        longitude:item.location.longitude,
        // latitude:item.latitude,
        // longitude:item.longitude,
       }
    })
    // 调用微信小程序JavaScript SDK 里面距离计算的方法 调用距离计算接口
    this.mapSdk.calculateDistance({
        //from参数不填默认当前地址
        //获取表单提交的经纬度并设置from和to参数（示例为string格式）
        // from: 若起点有数据则采用起点坐标，若为空默认当前地址，可以不写
        to: locationList, //终点坐标
        success:(res)=>{//成功后的回调
          //9. 获取到数据，对storeList进行处理
          // console.log(res);
          storeList.forEach((item,key)=>{
            //10. 给storeList添加一个新的键（distance）和值，并且将米转成千米
            storeList[key]['distance'] =( res.result.elements[key].distance/1000).toFixed(2)
          })
          this.setData({
            storeList
          })
        },
        fail: function(error) {
          console.error(error);
        }
    })
    // 10.上面塞进去之后这里就不需要return数据了
    // return data
  },

  //4. SDK方法
  initMapSdk(){
  // 实例化SDK 
    this.mapSdk = new QQMapWX({
      // 文档-组件-map-小程序地图插件使用指南-开发文档-微信小程序JavaScript SDK - 申请密匙-开启不验证域名-没有报错-文档-距离计算
      key:'5CSBZ-GOXKJ-2STFF-FFMDX-25IGO-KSBQ6'
    })
  } 
})
```

#### 实现点击地图进入地图详情页&点击手机号拨打电话

1. pages/store/index.wxml

```js
实现思路：
1. 绑定点击事件 navigateLocation 和 call
2. 调用官方的API	 wx.openLocation  和 wx.makePhoneCall
API - 位置 - wx.openLocation
https://developers.weixin.qq.com/miniprogram/dev/api/location/wx.getLocation.html
API - 设备 - 电话 - wx.makePhoneCall
https://developers.weixin.qq.com/miniprogram/dev/api/device/phone/wx.makePhoneCall.html
```

```html
<view class="page">
  <view class="header">
    <!-- 可以设置数组和对象，对象有利于指定key  抽离切换栏组件-->
    <tabs tabs="{{ [{value:'nearby',label:'附近门店'},{value:'recent',label:'常去门店'}] }}"></tabs>
    <input type="text" class="search" placeholder="搜索门店" />
  </view>
  <!-- map 区域  从官方直接拿 longitude latitude经纬度 bindmarkertap点开时候的位置 -->
  <map id="store-map" class="store-map" latitude="{{latitude}}" longitude="{{longitude}}" show-location markers="{{markers}}">
    <image bindtap="gotoCurrentLocation" class="current-icon" src="../../assets/images/current.png"></image>
  </map>
  <!-- 收起地图文字信息  -->
  <view class="collapse-area">
    <view class="collapse-tip">收起地图</view>
    <image src="../../assets/images/up.png"></image>
  </view>
  <!-- 店铺信息 -->
  <scroll-view class="store-list" scroll-y>
    <view class="store-box" wx:for="{{storeList}}" wx:key="index">
      <view class="info-area">
        <view class="name">{{ item.name }}</view>
        <view class="info">{{item.address}}</view>
        <view class="info">营业时间: {{item.opening_time}}</view>
    <!-- <view class="tag">{{item.status}}</view> 这里需要对数据进行处理，小程序过滤器有点问题 -->
        <view class="tag">{{dict[item.status]}}</view>
      </view>
      <view class="location-area">
        <view class="distance">距离 {{item.distance}} km</view>
        <view class="action-area">
          <view class="location">
              <!-- 绑定事件传入参数 -->
            <image class="location" bindtap="navigateLocation" data-location="{{item.location}}" src="../../assets/images/location.jpg"></image>
            <image class="phone" bindtap="call" src="../../assets/images/phone.jpg"></image>
          </view>
        </view>
      </view>
    </view>
  </scroll-view>
</view>
```

2. pages/store/index.js     14~16

```js
// pages/store/index.js
// 11. 引入计算属性，对markers进行处理
const computedBehavior = require('miniprogram-computed').behavior
//1. 引入SDK核心类，js文件根据自己业务，位置可自行放置
var QQMapWX = require('../../utils/qqmap-wx-jssdk.min');
import storeApi from '../../api/store';
Page({
  //12. 引入
  behaviors: [computedBehavior],
  data: { 
    longitude:113.613347,
    latitude:34.748349,
    // 地图上的蜜雪冰城标记点，自定义 markers
    // 14. 这里将原来的 markers 删除
    // markers:[ 
    //   {id:1,title:'实际位置',latitude:34.748349,longitude:113.613347,iconPath:'../../assets/images/marker.png', 
    //   width:'55rpx',height:'69rpx'}
    // ],
    storeList:[],    // 门店列表数据  
    // 但是我们里面的 status 是OPENING，我们需要对应成 营业中
    dict:{
      'OPENING':'营业中',
      'CLOSED':'已关店'
    },
  },
   // 13. 对markers数据进行处理
   computed: {
    // 根据形参里面的值的变化，去动态的修改 markers 的变化
    markers(data) {
      // console.log(data.storeList);
    // 注意： computed 函数中不能访问 this ，只有 data 对象可供访问
   return data.storeList.map((item,index)=>{
      return {
        // 这个 id 需要 Number 类型
        id: index + 1,
        key:item._id,
        title:item.name,
        latitude:item.location.latitude,
        longitude:item.location.longitude,
        iconPath:'../../assets/images/marker.png',
        width:'55rpx', height:'69rpx'
      }
    })
  },
},

  //1. 在当前页面增加了一个成员变量 mapContext，封装到全局变量中全局就可以调用
  mapContext:null,
  // 2. 定义全局 mapSdk
  mapSdk:null,

 async onLoad(options) {
    // 调用封装的获取位置信息方法
    this.loadCurrentLocation()  
    // 作用从当前位置获取context，并且赋值到成员变量mapContext中
    this.initMapContext()
    // 获取storeList的方法，在拿到位置数据信息之后再执行，或者将这个方法放进loadCurrentLocation方法里面
    await this.fetchStoreList()
    //3. sdk的方法
    this.initMapSdk();
  },

  //3. 点击回到中心点位置
  gotoCurrentLocation(){
    // 4. 任何一个位置只要点击就回到当前位置
    this.mapContext.moveToLocation()
  },
  
  // 封装获取位置信息方法
  loadCurrentLocation(){
    // 获取当前位置信息
    wx.getLocation({
      type: 'gcj02',
      altitude: true, //高精度定位
      success: (res)=> {
        const latitude = res.latitude
        const longitude = res.longitude
        this.setData({
          latitude,
          longitude
        })
      }
    })
  },

  // 封装加载 mapContext的方法
  initMapContext(){
    // 点击右下角小图标返回当前位置  
    wx.createSelectorQuery().select('#store-map').context(res=>{
      //2. 刚加载页面的时候我们进行一个对 mapContext 的获取
      this.mapContext = res.context;
    }).exec()
  },

  // 获取门店列表数据方法
  fetchStoreList(){
    //7. 改造之后，这里需要传入参数，这里获取的门店数据是store.js里面修改后的多远范围内的数据
    storeApi.list(this.data.longitude,this.data.latitude).then(res =>{
      // 只是这样获取data是空的，创建的模型在数据库中默认是谁创建谁来看，因为在上下文中会拿到openId，然后当前模拟用户里面是没有openId的，所以这里没有权限拿到这些东西。进入云开发-数据库-store-数据权限-所有用户可读，仅创建者可读写
      // console.log(res);
      //5. 在数据放入storeList列表之前，先对数据进行排序处理
      this.makeStoreList(res.data)
    })
  },

  //6. 对数据进行处理的方法
  makeStoreList(storeList){
    // 根据列表里面的经度和维度，再匹配当前位置的经度维度，把距离计算出来，增加一个新的属性，塞到storeList里面
    const locationList = storeList.map(item=>{
      return {
        //8. 这里根据数据库中的字段获取经纬度，如果只有一个location字段可以选用第一种方式获取
        latitude:item.location.latitude,
        longitude:item.location.longitude,
        // latitude:item.latitude,
        // longitude:item.longitude,
       }
    })
    // 调用微信小程序JavaScript SDK 里面距离计算的方法 调用距离计算接口
    this.mapSdk.calculateDistance({
        //from参数不填默认当前地址
        //获取表单提交的经纬度并设置from和to参数（示例为string格式）
        // from: 若起点有数据则采用起点坐标，若为空默认当前地址，可以不写
        to: locationList, //终点坐标
        success:(res)=>{//成功后的回调
          //9. 获取到数据，对storeList进行处理
          // console.log(res);
          storeList.forEach((item,key)=>{
            //10. 给storeList添加一个新的键（distance）和值，并且将米转成千米
            storeList[key]['distance'] =( res.result.elements[key].distance/1000).toFixed(2)
          })
          this.setData({
            storeList
          })
        },
        fail: function(error) {
          console.error(error);
        }
    })
    // 10.上面塞进去之后这里就不需要return数据了
    // return data
  },

  //4. SDK方法
  initMapSdk(){
  // 实例化SDK 
    this.mapSdk = new QQMapWX({
      // 文档-组件-map-小程序地图插件使用指南-开发文档-微信小程序JavaScript SDK - 申请密匙-开启不验证域名-没有报错-文档-距离计算
      key:'5CSBZ-GOXKJ-2STFF-FFMDX-25IGO-KSBQ6'
    })
  },

  // 14. 实现点击导航的事件，进入地图界面
  navigateLocation(e){
    //15. 接收传过来的参数
    const {latitude,longitude} =e.currentTarget.dataset.location
    console.log(e);
    wx.openLocation({
      latitude,
      longitude
    })
  },

  // 16. 实现点击电话调用API
  call(e){
    // console.log(e);
    const {phone} = e.currentTarget.dataset
    wx.makePhoneCall({
      phoneNumber:phone
    })
  }
})
```

#### 门店详情弹窗页面

```js
todo:
1. 作为访客我可以在点餐模块查看到地图并在地图中看到我附近商铺位置，点击可以查看商铺
2. 作为访客，我可以再点餐这里搜索地点名称查看到地点附近的商品列表
3. 这里的弹窗组件是使用的小程序中提供的 page-container
https://developers.weixin.qq.com/miniprogram/dev/component/page-container.html
4. 在门店列表中添加点击事件，并且将门店数据传入
bindtap="popupStoreDetail" data-store="{{item}}"
5. 渲染数据
6. 实现展开地图与收起地图功能
7. 定义状态，当点击的时候触发，触发之后对状态取反，在wxml中用三元表达式判断高度，设置style属性
```

1. pages/store/index.wxml

```html
<view class="page">
  <view class="header">
    <!-- 可以设置数组和对象，对象有利于指定key  抽离切换栏组件-->
    <tabs tabs="{{ [{value:'nearby',label:'附近门店'},{value:'recent',label:'常去门店'}] }}"></tabs>
    <input type="text" class="search" placeholder="搜索门店" />
  </view>
  <!-- map 区域  从官方直接拿 longitude latitude经纬度 bindmarkertap点开时候的位置 -->
  <map id="store-map" class="store-map" style="height: {{collapse ? '0':'520rpx'}};" latitude="{{latitude}}" longitude="{{longitude}}" show-location markers="{{markers}}">
    <image bindtap="gotoCurrentLocation" class="current-icon" src="../../assets/images/current.png"></image>
  </map>
  <!-- 收起地图文字信息  -->
  <view class="collapse-area" bindtap="collapse">
    <view class="collapse-tip">{{collapse ? '展开地图':'收起地图'}}</view>
    <image class="icon" src="{{ '../../assets/icons/arrow-'+(collapse ?'down':'up')+'.svg' }}"></image>
  </view>
  <!-- 店铺信息 -->
  <scroll-view class="store-list" scroll-y style="height: {{collapse ? '100%':'calc(100vh - 700rpx)'}} ;">
    <view class="store-box" wx:for="{{storeList}}" wx:key="index" bindtap="popupStoreDetail" data-store="{{item}}">
      <view class="info-area">
        <view class="name">{{ item.name }}</view>
        <view class="info">{{item.address}}</view>
        <view class="info">营业时间: {{item.opening_time}}</view>
        <!-- <view class="tag">{{item.status}}</view> 这里需要对数据进行处理，小程序过滤器有点问题 -->
        <view class="tag">{{dict[item.status]}}</view>
      </view>
      <view class="location-area">
        <view class="distance">距离 {{item.distance}} km</view>
        <view class="action-area">
          <view class="location">
            <image class="location" bindtap="navigateLocation" data-location="{{item.location}}" src="../../assets/images/location.jpg"></image>
            <image class="phone" bindtap="call" data-phone="{{item.phone}}" src="../../assets/images/phone.jpg"></image>
          </view>
        </view>
      </view>
    </view>
  </scroll-view>

  <!-- 弹窗组件  round 圆角默认是true  star-->
  <page-container wx:if="{{ currentStore }}" show="{{ storeDetailShow }}" round position="bottom" class="store-detail">
    <!-- 公告区域 -->
    <view class="notification">
      <image class="icon" src="../../assets/icons/speaker.svg"></image>
      <view class="info">我们的门店很多，千万不要写错哦~</view>
    </view>
    <view class="container">
      <view class="header-area">
      <view class="info">
        <view class="title">{{ currentStore.name }}</view>
        <view class="address">{{ currentStore.address }}</view>
      </view>
      <view class="distance">
        距离<view class="number">{{ currentStore.distance }}km</view>
      </view>
    </view>

    <!-- 地图 -->
    <map id="store-detail" class="store-detail-map" latitude="{{ currentStore.location.latitude }}" longitude="{{ currentStore.location.longitude }}" show-location markers="{{ markers }}">
    </map>
    <!-- 按钮 -->
    <button class="menu-btn">进入菜单</button>
  </view>  
  </page-container>
  <!-- 弹窗组件 end-->
</view>
```

2. pages/store/index.css

```scss
@import '../../style/theme.scss';
.header{
  display: flex;
  padding:0 30rpx;
  box-sizing: border-box;
  width: 100%;
  justify-content: space-between;
  align-items: center;
  height: 109rpx;
  .search{
    width: 174rpx;
    height: 58rpx;
    background-color: #f5f5f5;
    padding: 18rpx 26rpx;
    border-radius: 29rpx;
    box-sizing: border-box;
    padding:0 26rpx;
    font-size: 28rpx;
    color: #d1d1d1;
  }
}
.store-map{
  width: 100%;
  height: 520rpx;
  transition: all 0.5s;
  position: relative;
  .current-icon{
    width: 44rpx;
    height: 44rpx;
    position: absolute;
    right: 18rpx;
    bottom: 22rpx;
  }
}
.collapse-area{
  width: 100%;
  height: 70rpx;
  display: flex;
  justify-content: center;
  align-items: center;
  font-size: 23rpx;
  color: $gray-text-color;
  .icon{
    width: 30rpx;
    height: 30rpx;
    margin-left: 10rpx;
  }
}
.store-list{
  width: 100%;
  transition: all 0.5s;
  height: calc(100vh - 700rpx);
  background-color: #f8f8f8;
  // 小程序一般都是怪异盒子模型，所以一般都是需要设置 box-sizing 的
  box-sizing: border-box;
  .store-box{
    background-color: #ffffff;
    padding:25rpx;
    margin: 14rpx 25rpx;
    display: flex;
    align-items: center;
    .info-area{
      border-right: 1px solid #eeeeee;
      // 这样弹性盒子的效果就出来了，占满后面的空间
      flex: 1;
      .name{
        font-size: 28rpx;
        font-weight: bold;
        margin-bottom:12rpx;
      }
      .info{
        font-size: 18rpx;
        color: $gray-text-color;
        margin-bottom: 12rpx;
      }
      .tag{
        // 这样不是一个block，是一个inline的话就可以做 padding 了
        display: inline-block;
        background-color: $primary-color;
        color: #fff;
        font-size: 18rpx;
        padding: 6rpx;
      }
    }
    .location-area{
      height: 112rpx;
      margin-left: 25rpx;
      display: flex;
      flex-direction: column;
      align-items: center;
      .distance{
        font-size: 20rpx;
        color: $gray-text-color;
        margin-bottom: 35rpx;
      }
      .action-area{
        display: flex;
        width: 112rpx;
        justify-content: space-around;
        image{
          width: 40rpx;
          height: 40rpx;
        }
      }
    }
  }
}

.store-detail{
  .notification{
    display: flex;
    width: 100%;
    height: 86rpx;
    align-items: center;
    background-color: #fcf0f4;
    padding:0 30rpx;
    .icon{
      width: 38rpx;
      height: 38rpx;
      margin-right: 14rpx;
    }
    .info{
      color: $primary-color;
      font-size: 20rpx;
    }
  }
  .container{
    padding: 0 30rpx;
    .header-area{
      margin: 25rpx 0rpx; 
      display: flex;
      justify-content: space-between;
      align-items: center;
      .info{
        .title{
          font-size: 26rpx;
          font-weight: bold;
          line-height: 26rpx;
          margin-bottom: 14rpx;
        }
        .address{
          font-size: 20rpx;
          line-height: 20rpx;
          color: $gray-text-color;
        }
      }
      .distance{
        color: $gray-text-color;
        font-size: 20rpx;
        width: 130rpx;
        display: flex;
        margin-top: -40rpx;
        .number{
          color: $primary-color;
          margin-left: 5rpx;
        }
      }
    }
    .store-detail-map{
      width: 100%;
      height: 392rpx;
      margin: 25rpx 0rpx;
    }
  }
  .menu-btn{
    width: 100%;
    height: 85rpx;
    background-color:$primary-color;
    color: white;
    border-radius: 10rpx;
    display: flex;
    justify-content: center;
    align-items: center;
    margin-bottom: 42rpx;
    &.button-hover{
      opacity: 0.6;
    }
  }
}
```

3. pages/store/index.js

```js
// pages/store/index.js
// 11. 引入计算属性，对markers进行处理
const computedBehavior = require('miniprogram-computed').behavior
//1. 引入SDK核心类，js文件根据自己业务，位置可自行放置
var QQMapWX = require('../../utils/qqmap-wx-jssdk.min');
import storeApi from '../../api/store';
Page({
  //12. 引入
  behaviors: [computedBehavior],
  data: { 
    longitude:113.554637,
    latitude:34.818552,
    // 地图上的蜜雪冰城标记点，自定义 markers
    // 14. 这里将原来的 markers 删除
    // markers:[ 
    //   {id:1,title:'实际位置',latitude:34.748349,longitude:113.613347,iconPath:'../../assets/images/marker.png', 
    //   width:'55rpx',height:'69rpx'}
    // ],
    storeList:[],    // 门店列表数据  
    // 但是我们里面的 status 是OPENING，我们需要对应成 营业中
    dict:{
      'OPENING':'营业中',
      'CLOSED':'已关店'
    },
    storeDetailShow:false,    // 弹窗组件是否显示   
    currentStore:null,     //17. 定义一个新的变量存储数据，用于弹窗数据显示 
    collapse:false,    // 收起与展开地图的状态
  },
   // 13. 对markers数据进行处理
   computed: {
    // 根据形参里面的值的变化，去动态的修改 markers 的变化
    markers(data) {
      // console.log(data.storeList);
    // 注意： computed 函数中不能访问 this ，只有 data 对象可供访问
   return data.storeList.map((item,index)=>{
      return {
        // 这个 id 需要 Number 类型
        id: index + 1,
        key:item._id,
        title:item.name,
        latitude:item.location.latitude,
        longitude:item.location.longitude,
        iconPath:'../../assets/images/marker.png',
        width:'55rpx', height:'69rpx'
      }
    })
  },
},

  //1. 在当前页面增加了一个成员变量 mapContext，封装到全局变量中全局就可以调用
  mapContext:null,
  // 2. 定义全局 mapSdk
  mapSdk:null,

 async onLoad(options) {
    // 调用封装的获取位置信息方法
    this.loadCurrentLocation()  
    // 作用从当前位置获取context，并且赋值到成员变量mapContext中
    this.initMapContext()
    // 获取storeList的方法，在拿到位置数据信息之后再执行，或者将这个方法放进loadCurrentLocation方法里面
    await this.fetchStoreList()
    //3. sdk的方法
    this.initMapSdk();
  },

  //3. 点击回到中心点位置
  gotoCurrentLocation(){
    // 4. 任何一个位置只要点击就回到当前位置
    this.mapContext.moveToLocation()
  },
  
  // 封装获取位置信息方法
  loadCurrentLocation(){
    // 获取当前位置信息
    wx.getLocation({
      type: 'gcj02',
      altitude: true, //高精度定位
      success: (res)=> {
        const latitude = res.latitude
        const longitude = res.longitude
        this.setData({
          latitude,
          longitude
        })
      }
    })
  },

  // 封装加载 mapContext的方法
  initMapContext(){
    // 点击右下角小图标返回当前位置  
    wx.createSelectorQuery().select('#store-map').context(res=>{
      //2. 刚加载页面的时候我们进行一个对 mapContext 的获取
      this.mapContext = res.context;
    }).exec()
  },

  // 获取门店列表数据方法
  fetchStoreList(){
    //7. 改造之后，这里需要传入参数，这里获取的门店数据是store.js里面修改后的多远范围内的数据
    storeApi.list(this.data.longitude,this.data.latitude).then(res =>{
      // 只是这样获取data是空的，创建的模型在数据库中默认是谁创建谁来看，因为在上下文中会拿到openId，然后当前模拟用户里面是没有openId的，所以这里没有权限拿到这些东西。进入云开发-数据库-store-数据权限-所有用户可读，仅创建者可读写
      // console.log(res);
      //5. 在数据放入storeList列表之前，先对数据进行排序处理
      this.makeStoreList(res.data)
    })
  },

  //6. 对数据进行处理的方法
  makeStoreList(storeList){
    // 根据列表里面的经度和维度，再匹配当前位置的经度维度，把距离计算出来，增加一个新的属性，塞到storeList里面
    const locationList = storeList.map(item=>{
      return {
        //8. 这里根据数据库中的字段获取经纬度，如果只有一个location字段可以选用第一种方式获取
        latitude:item.location.latitude,
        longitude:item.location.longitude,
        // latitude:item.latitude,
        // longitude:item.longitude,
       }
    })
    // 调用微信小程序JavaScript SDK 里面距离计算的方法 调用距离计算接口
    this.mapSdk.calculateDistance({
        //from参数不填默认当前地址
        //获取表单提交的经纬度并设置from和to参数（示例为string格式）
        // from: 若起点有数据则采用起点坐标，若为空默认当前地址，可以不写
        to: locationList, //终点坐标
        success:(res)=>{//成功后的回调
          //9. 获取到数据，对storeList进行处理
          // console.log(res);
          storeList.forEach((item,key)=>{
            //10. 给storeList添加一个新的键（distance）和值，并且将米转成千米
            storeList[key]['distance'] =( res.result.elements[key].distance/1000).toFixed(2)
          })
          this.setData({
            storeList
          })
        },
        fail: function(error) {
          console.error(error);
        }
    })
    // 10.上面塞进去之后这里就不需要return数据了
    // return data
  },

  //4. SDK方法
  initMapSdk(){
  // 实例化SDK 
    this.mapSdk = new QQMapWX({
      // 文档-组件-map-小程序地图插件使用指南-开发文档-微信小程序JavaScript SDK - 申请密匙-开启不验证域名-没有报错-文档-距离计算
      key:'5CSBZ-GOXKJ-2STFF-FFMDX-25IGO-KSBQ6'
    })
  },

  // 14. 实现点击导航的事件，进入地图界面
  navigateLocation(e){
    //15. 接收传过来的参数
    const {latitude,longitude} =e.currentTarget.dataset.location
    console.log(e);
    wx.openLocation({
      latitude,
      longitude
    })
  },

  // 15. 实现点击电话调用API
  call(e){
    // console.log(e);
    const {phone} = e.currentTarget.dataset
    wx.makePhoneCall({
      phoneNumber:phone
    })
  },

  //16. 点击门店绑定门店数据，显示弹窗
  popupStoreDetail(e){
    const {store} = e.currentTarget.dataset
    this.setData({
      currentStore:store,
      storeDetailShow:true
    })
  },

  // 17. 展开收起地图
  collapse(){
    this.setData({
      collapse:!this.data.collapse
    })
  }
})
```

#### 搜索功能&点击地图marker显示弹窗&根据搜素地获取附近门店         

```js
文档位置：https://lbs.qq.com/miniProgram/plugin/pluginGuide/locationPicker
1. 地图 - map - 小程序地图插件使用指南 - 在腾讯微信公众平台中， “微信小程序官方后台-设置-第三方服务-插件管理” 里点击 “添加插件”，搜索 “腾讯位置服务地图选点” 申请
2.引入插件包：
// app.json
{
    "plugins": {
        "chooseLocation": {
        "version": "1.0.9",
        "provider": "wx76a9a06e5b4e693e"
        }
    }
}  
3. 设置定位授权：
地图选点插件需要小程序提供定位授权才能够正常使用定位功能：
// app.json
{
    "permission": {
        "scope.userLocation": {
        "desc": "你的位置信息将用于小程序定位"
        }
    }
}
4. 使用插件：
插件页面调用示例：
const key = ''; //使用在腾讯位置服务申请的key
const referer = ''; //调用插件的app的名称
const location = JSON.stringify({
  latitude: 39.89631551,
  longitude: 116.323459711
});
const category = '生活服务,娱乐休闲';
 
wx.navigateTo({
  url: 'plugin://chooseLocation/index?key=' + key + '&referer=' + referer + '&location=' + location + '&category=' + category
});
5. 给搜索框添加点击事件
<input bindtap="chooseLocation" type="text" class="search" placeholder="搜索门店" />
6. 对方法进行改造
  //18. 点击选择门店
  chooseLocation(){
    const key = this.data.mapKey; //使用在腾讯位置服务申请的key，使用的是小程序的key，这个定义在了最上面的全局里面
    const referer = 'mixuebingcheng'; //调用插件的app的名称
    const location = JSON.stringify({
      latitude: this.data.latitude,
      longitude: this.data.longitude
    });
    wx.navigateTo({
      url: 'plugin://chooseLocation/index?key=' + key + '&referer=' + referer + '&location=' + location 
    });
  }
})
7.在选取地点之后的操作
const chooseLocation = requirePlugin('chooseLocation');
Page({
    // 从地图选点插件返回后，在页面的onShow生命周期函数中能够调用插件接口，取得选点结果对象
    onShow () {
        const location = chooseLocation.getLocation(); // 如果点击确认选点按钮，则返回选点结果对象，否则返回null
    },
    onUnload () {
        // 页面卸载时设置插件选点数据为null，防止再次进入页面，geLocation返回的是上次选点结果
        chooseLocation.setLocation(null);
    }
})
```

1. pages/store/index.wxml

```html
<view class="page">
  <view class="header">
    <!-- 可以设置数组和对象，对象有利于指定key  抽离切换栏组件-->
    <tabs tabs="{{ [{value:'nearby',label:'附近门店'},{value:'recent',label:'常去门店'}] }}"></tabs>
    <input bindtap="chooseLocation" type="text" class="search" placeholder="搜索门店" />
  </view>
  <!-- map 区域  从官方直接拿 longitude latitude经纬度 bindmarkertap点开时候的位置 -->
  <map id="store-map" class="store-map" style="height: {{collapse ? '0':'520rpx'}};" latitude="{{latitude}}" longitude="{{longitude}}" show-location markers="{{markers}}" bindmarkertap="onMarkerTab">
    <image bindtap="gotoCurrentLocation" class="current-icon" src="../../assets/images/current.png"></image>
  </map>
  <!-- 收起地图文字信息  -->
  <view class="collapse-area" bindtap="collapse">
    <view class="collapse-tip">{{collapse ? '展开地图':'收起地图'}}</view>
    <image class="icon" src="{{ '../../assets/icons/arrow-'+(collapse ?'down':'up')+'.svg' }}"></image>
  </view>
  <!-- 店铺信息 -->
  <scroll-view  class="store-list" scroll-y style="height: {{collapse ? '100%':'calc(100vh - 700rpx)'}} ;">
    <view class="store-box" wx:for="{{storeList}}" wx:key="index" bindtap="popupStoreDetail" data-store="{{item}}">
      <view class="info-area">
        <view class="name">{{ item.name }}</view>
        <view class="info">{{item.address}}</view>
        <view class="info">营业时间: {{item.opening_time}}</view>
        <!-- <view class="tag">{{item.status}}</view> 这里需要对数据进行处理，小程序过滤器有点问题 -->
        <view class="tag">{{dict[item.status]}}</view>
      </view>
      <view class="location-area">
        <view class="distance">距离 {{item.distance}} km</view>
        <view class="action-area">
          <view class="location">
            <image class="location" bindtap="navigateLocation" data-location="{{item.location}}" src="../../assets/images/location.jpg"></image>
            <image class="phone" bindtap="call" data-phone="{{item.phone}}" src="../../assets/images/phone.jpg"></image>
          </view>
        </view>
      </view>
    </view>
    <view class="empty" wx:if="{{storeList.length === 0}}">抱歉附近没有门店</view>
  </scroll-view>
 

  <!-- 弹窗组件  round 圆角默认是true  star-->
  <page-container wx:if="{{ currentStore }}" show="{{ storeDetailShow }}" round position="bottom" class="store-detail">
    <!-- 公告区域 -->
    <view class="notification">
      <image class="icon" src="../../assets/icons/speaker.svg"></image>
      <view class="info">我们的门店很多，千万不要写错哦~</view>
    </view>
    <view class="container">
      <view class="header-area">
      <view class="info">
        <view class="title">{{ currentStore.name }}</view>
        <view class="address">{{ currentStore.address }}</view>
      </view>
      <view class="distance">
        距离<view class="number">{{ currentStore.distance }}km</view>
      </view>
    </view>

    <!-- 地图 -->
    <map id="store-detail" class="store-detail-map" latitude="{{ currentStore.location.latitude }}" longitude="{{ currentStore.location.longitude }}" show-location markers="{{ markers }}">
    </map>
    <!-- 按钮 -->
    <button class="menu-btn">进入菜单</button>
  </view>  
  </page-container>
  <!-- 弹窗组件 end-->
</view>
```

2. pages/store/index.scss

```scss
@import '../../style/theme.scss';
.header{
  display: flex;
  padding:0 30rpx;
  box-sizing: border-box;
  width: 100%;
  justify-content: space-between;
  align-items: center;
  height: 109rpx;
  .search{
    width: 174rpx;
    height: 58rpx;
    background-color: #f5f5f5;
    padding: 18rpx 26rpx;
    border-radius: 29rpx;
    box-sizing: border-box;
    padding:0 26rpx;
    font-size: 28rpx;
    color: #d1d1d1;
  }
}
.store-map{
  width: 100%;
  height: 520rpx;
  transition: all 0.5s;
  position: relative;
  .current-icon{
    width: 44rpx;
    height: 44rpx;
    position: absolute;
    right: 18rpx;
    bottom: 22rpx;
  }
}
.collapse-area{
  width: 100%;
  height: 70rpx;
  display: flex;
  justify-content: center;
  align-items: center;
  font-size: 23rpx;
  color: $gray-text-color;
  .icon{
    width: 30rpx;
    height: 30rpx;
    margin-left: 10rpx;
  }
}
.store-list{
  width: 100%;
  transition: all 0.5s;
  height: calc(100vh - 700rpx);
  background-color: #f8f8f8;
  // 小程序一般都是怪异盒子模型，所以一般都是需要设置 box-sizing 的
  box-sizing: border-box;
  .empty{
    color: $gray-text-color;
    display: flex;
    justify-content: center;
    font-size: 20rpx;
    margin-top: 30rpx;
  }
  .store-box{
    background-color: #ffffff;
    padding:25rpx;
    margin: 14rpx 25rpx;
    display: flex;
    align-items: center;
    .info-area{
      border-right: 1px solid #eeeeee;
      // 这样弹性盒子的效果就出来了，占满后面的空间
      flex: 1;
      .name{
        font-size: 28rpx;
        font-weight: bold;
        margin-bottom:12rpx;
      }
      .info{
        font-size: 18rpx;
        color: $gray-text-color;
        margin-bottom: 12rpx;
      }
      .tag{
        // 这样不是一个block，是一个inline的话就可以做 padding 了
        display: inline-block;
        background-color: $primary-color;
        color: #fff;
        font-size: 18rpx;
        padding: 6rpx;
      }
    }
    .location-area{
      height: 112rpx;
      margin-left: 25rpx;
      display: flex;
      flex-direction: column;
      align-items: center;
      .distance{
        font-size: 20rpx;
        color: $gray-text-color;
        margin-bottom: 35rpx;
      }
      .action-area{
        display: flex;
        width: 112rpx;
        justify-content: space-around;
        image{
          width: 40rpx;
          height: 40rpx;
        }
      }
    }
  }
}

.store-detail{
  .notification{
    display: flex;
    width: 100%;
    height: 86rpx;
    align-items: center;
    background-color: #fcf0f4;
    padding:0 30rpx;
    .icon{
      width: 38rpx;
      height: 38rpx;
      margin-right: 14rpx;
    }
    .info{
      color: $primary-color;
      font-size: 20rpx;
    }
  }
  .container{
    padding: 0 30rpx;
    .header-area{
      margin: 25rpx 0rpx; 
      display: flex;
      justify-content: space-between;
      align-items: center;
      .info{
        .title{
          font-size: 26rpx;
          font-weight: bold;
          line-height: 26rpx;
          margin-bottom: 14rpx;
        }
        .address{
          font-size: 20rpx;
          line-height: 20rpx;
          color: $gray-text-color;
        }
      }
      .distance{
        color: $gray-text-color;
        font-size: 20rpx;
        width: 130rpx;
        display: flex;
        margin-top: -40rpx;
        .number{
          color: $primary-color;
          margin-left: 5rpx;
        }
      }
    }
    .store-detail-map{
      width: 100%;
      height: 392rpx;
      margin: 25rpx 0rpx;
    }
  }
  .menu-btn{
    width: 100%;
    height: 85rpx;
    background-color:$primary-color;
    color: white;
    border-radius: 10rpx;
    display: flex;
    justify-content: center;
    align-items: center;
    margin-bottom: 42rpx;
    &.button-hover{
      opacity: 0.6;
    }
  }
}
```

3. pages/store/index.js   18~23

```js
// pages/store/index.js
// 11. 引入计算属性，对markers进行处理
const computedBehavior = require('miniprogram-computed').behavior
const key = '5CSBZ-GOXKJ-2STFF-FFMDX-25IGO-KSBQ6'
//1. 引入SDK核心类，js文件根据自己业务，位置可自行放置
var QQMapWX = require('../../utils/qqmap-wx-jssdk.min');
import storeApi from '../../api/store';
const chooseLocation = requirePlugin('chooseLocation');
Page({
  //12. 引入
  behaviors: [computedBehavior],
  data: { 
    longitude:113.554637,
    latitude:34.818552,
    // 地图上的蜜雪冰城标记点，自定义 markers
    // 14. 这里将原来的 markers 删除
    // markers:[ 
    //   {id:1,title:'实际位置',latitude:34.748349,longitude:113.613347,iconPath:'../../assets/images/marker.png', 
    //   width:'55rpx',height:'69rpx'}
    // ],
    storeList:[],    // 门店列表数据  
    // 但是我们里面的 status 是OPENING，我们需要对应成 营业中
    dict:{
      'OPENING':'营业中',
      'CLOSED':'已关店'
    },
    storeDetailShow:false,    // 弹窗组件是否显示   
    currentStore:null,     //17. 定义一个新的变量存储数据，用于弹窗数据显示 
    collapse:false,    // 收起与展开地图的状态
    mapKey:key,    // 定义一个复用的key
  },
   // 13. 对markers数据进行处理
   computed: {
    // 根据形参里面的值的变化，去动态的修改 markers 的变化
    markers(data) {
      // console.log(data.storeList);
    // 注意： computed 函数中不能访问 this ，只有 data 对象可供访问
   return data.storeList.map((item,index)=>{
      return {
        // 这个 id 需要 Number 类型
        id: index + 1,
        key:item._id,
        title:item.name,
        latitude:item.location.latitude,
        longitude:item.location.longitude,
        iconPath:'../../assets/images/marker.png',
        width:'55rpx', height:'69rpx'
      }
    })
  },
},

  //1. 在当前页面增加了一个成员变量 mapContext，封装到全局变量中全局就可以调用
  mapContext:null,
  // 2. 定义全局 mapSdk
  mapSdk:null,

 async onLoad(options) {
    // 调用封装的获取位置信息方法
    this.loadCurrentLocation()  
    // 作用从当前位置获取context，并且赋值到成员变量mapContext中
    this.initMapContext()
    // 获取storeList的方法，在拿到位置数据信息之后再执行，或者将这个方法放进loadCurrentLocation方法里面
    await this.fetchStoreList()
    //3. sdk的方法
    this.initMapSdk();
  },

  //3. 点击回到中心点位置
  gotoCurrentLocation(){
    // 4. 任何一个位置只要点击就回到当前位置
    this.mapContext.moveToLocation()
    //23. 当我们选取了其他位置之后，想要再次回来，那么我们就需要重新调用方法，获取门店数据
    this.loadCurrentLocation()
  },
  
  // 封装获取位置信息方法
  loadCurrentLocation(){
    // 获取当前位置信息
    wx.getLocation({
      type: 'gcj02',
      altitude: true, //高精度定位
      success: (res)=> {
        const latitude = res.latitude
        const longitude = res.longitude
        this.setData({
          latitude,
          longitude
        })
      }
    })
  },

  // 封装加载 mapContext的方法
  initMapContext(){
    // 点击右下角小图标返回当前位置  
    wx.createSelectorQuery().select('#store-map').context(res=>{
      //2. 刚加载页面的时候我们进行一个对 mapContext 的获取
      this.mapContext = res.context;
    }).exec()
  },

  // 获取门店列表数据方法
  fetchStoreList(){
    //7. 改造之后，这里需要传入参数，这里获取的门店数据是store.js里面修改后的多远范围内的数据
    storeApi.list(this.data.longitude,this.data.latitude).then(res =>{
      // 只是这样获取data是空的，创建的模型在数据库中默认是谁创建谁来看，因为在上下文中会拿到openId，然后当前模拟用户里面是没有openId的，所以这里没有权限拿到这些东西。进入云开发-数据库-store-数据权限-所有用户可读，仅创建者可读写
      // console.log(res);
      //5. 在数据放入storeList列表之前，先对数据进行排序处理
      this.makeStoreList(res.data)
    })
  },

  //6. 对数据进行处理的方法
  makeStoreList(storeList){
    //22. 如果没有请求到数据，那么就要将门店信息设置为空，否则还是之前的数据
    if(storeList.length === 0){
      this.setData({
        storeList:[]
      })
    }
    // 根据列表里面的经度和维度，再匹配当前位置的经度维度，把距离计算出来，增加一个新的属性，塞到storeList里面
    const locationList = storeList.map(item=>{
      return {
        //8. 这里根据数据库中的字段获取经纬度，如果只有一个location字段可以选用第一种方式获取
        latitude:item.location.latitude,
        longitude:item.location.longitude,
        // latitude:item.latitude,
        // longitude:item.longitude,
       }
    })
    // 调用微信小程序JavaScript SDK 里面距离计算的方法 调用距离计算接口
    this.mapSdk.calculateDistance({
        //from参数不填默认当前地址
        from:{
          latitude: this.data.latitude,
          longitude:this.data.longitude
        },
        //获取表单提交的经纬度并设置from和to参数（示例为string格式）
        // from: 若起点有数据则采用起点坐标，若为空默认当前地址，可以不写
        to: locationList, //终点坐标
        success:(res)=>{//成功后的回调
          //9. 获取到数据，对storeList进行处理
          // console.log(res);
          storeList.forEach((item,key)=>{
            //10. 给storeList添加一个新的键（distance）和值，并且将米转成千米
            storeList[key]['distance'] =( res.result.elements[key].distance/1000).toFixed(2)
          })
          this.setData({
            storeList
          })
        },
        fail: function(error) {
          console.error(error);
        }
    })
    // 10.上面塞进去之后这里就不需要return数据了
    // return data
  },

  //4. SDK方法
  initMapSdk(){
  // 实例化SDK 
    this.mapSdk = new QQMapWX({
      // 文档-组件-map-小程序地图插件使用指南-开发文档-微信小程序JavaScript SDK - 申请密匙-开启不验证域名-没有报错-文档-距离计算，使用上面定义过的key
      key:key
    })
  },

  // 14. 实现点击导航的事件，进入地图界面
  navigateLocation(e){
    //15. 接收传过来的参数
    const {latitude,longitude} =e.currentTarget.dataset.location
    console.log(e);
    wx.openLocation({
      latitude,
      longitude
    })
  },

  // 15. 实现点击电话调用API
  call(e){
    // console.log(e);
    const {phone} = e.currentTarget.dataset
    wx.makePhoneCall({
      phoneNumber:phone
    })
  },

  //16. 点击门店绑定门店数据，显示弹窗
  popupStoreDetail(e){
    const {store} = e.currentTarget.dataset
    this.setData({
      currentStore:store,
      storeDetailShow:true
    })
  },

  // 17. 展开收起地图
  collapse(){
    this.setData({
      collapse:!this.data.collapse
    })
  },
  //18. 点击选择门店
  chooseLocation(){
    const key = this.data.mapKey; //使用在腾讯位置服务申请的key
    const referer = 'mixuebingcheng'; //调用插件的app的名称
    const location = JSON.stringify({
      latitude: this.data.latitude,
      longitude: this.data.longitude
    });
    wx.navigateTo({
      url: 'plugin://chooseLocation/index?key=' + key + '&referer=' + referer + '&location=' + location 
    });
  },

  // 19.选取地点之后的操作，获取具体位置
   // 从地图选点插件返回后，在页面的onShow生命周期函数中能够调用插件接口，取得选点结果对象
  async onShow () {
    const location = chooseLocation.getLocation(); // 如果点击确认选点按钮，则返回选点结果对象，否则返回null
    if(location){
      // console.log(location);    // 获取点击后的位置信息
      const {latitude,longitude} = location
      this.setData({
        latitude,
        longitude
      })
      // 重新调用方法去渲染页面中的数据，但是需要在步骤21里面设置起始位置，否则获取不到选取地点附近的信息，还是当前位置的数据 步骤22里面也要重置门店列表数据
      await this.fetchStoreList()
      }
    },

    //20. 页面卸载时
    onUnload () {
      // 页面卸载时设置插件选点数据为null，防止再次进入页面，geLocation返回的是上次选点结果
      chooseLocation.setLocation(null);
  },
  // 23. 点击地图上的marker 显示对应店铺的信息
  onMarkerTab(e){
    const { markerId } = e.detail
    // 这里将 markerId - 1，因为之前转为number的时候 +1
    const store = this.data.storeList[markerId -1]
    // 点击哪一个就是哪一个的门店数据
    // console.log(store);
    this.setData({
      currentStore:store,
      storeDetailShow:true
    })
  }
})
```

